/**
 * KICKOFF.md Management API
 *
 * Generates and manages KICKOFF.md files in project working directories.
 * These files provide context for Claude Code sessions about:
 * - Project information
 * - Current task/packet
 * - How to report status back to Claudia
 *
 * Endpoints:
 * - GET: Check if KICKOFF.md exists and return its contents
 * - POST: Generate/update KICKOFF.md with current project state
 */

import { NextRequest, NextResponse } from "next/server"
import { promises as fs } from "fs"
import { stat } from "fs/promises"
import path from "path"

// Import prompt injection filter for KICKOFF.md security
import {
  filterKickoffContent,
} from "@/lib/security/prompt-filter"
import {
  logSecurityEvent as logSecurityActivityEvent,
} from "@/lib/security/activity-log"

interface RouteParams {
  params: Promise<{ id: string }>
}

interface KickoffData {
  projectName: string
  projectDescription: string
  workingDirectory: string
  currentPacket?: {
    id: string
    title: string
    description: string
    type: string
    priority: string
    tasks: Array<{ id: string; description: string; completed: boolean }>
    acceptanceCriteria: string[]
  }
  allPackets?: Array<{
    id: string
    title: string
    status: string
  }>
}

/**
 * Generate KICKOFF.md content
 */
function generateKickoffContent(data: KickoffData): string {
  const lines: string[] = []

  // Header
  lines.push(`# KICKOFF: ${data.projectName}`)
  lines.push("")
  lines.push(`> This file is auto-generated by Claudia. Read this first to understand your task.`)
  lines.push("")

  // Project Overview
  lines.push("## Project Overview")
  lines.push("")
  lines.push(data.projectDescription || "No description provided.")
  lines.push("")
  lines.push(`**Working Directory:** \`${data.workingDirectory}\``)
  lines.push("")

  // Current Task
  if (data.currentPacket) {
    lines.push("## Current Task")
    lines.push("")
    lines.push(`### ${data.currentPacket.title}`)
    lines.push("")
    lines.push(`**Type:** ${data.currentPacket.type} | **Priority:** ${data.currentPacket.priority}`)
    lines.push("")
    lines.push(data.currentPacket.description)
    lines.push("")

    // Tasks checklist
    if (data.currentPacket.tasks && data.currentPacket.tasks.length > 0) {
      lines.push("### Tasks")
      lines.push("")
      for (const task of data.currentPacket.tasks) {
        const checkbox = task.completed ? "[x]" : "[ ]"
        lines.push(`- ${checkbox} ${task.description}`)
      }
      lines.push("")
    }

    // Acceptance criteria
    if (data.currentPacket.acceptanceCriteria && data.currentPacket.acceptanceCriteria.length > 0) {
      lines.push("### Acceptance Criteria")
      lines.push("")
      for (const criterion of data.currentPacket.acceptanceCriteria) {
        lines.push(`- ${criterion}`)
      }
      lines.push("")
    }
  } else {
    lines.push("## Current Task")
    lines.push("")
    lines.push("No specific task assigned. Explore the project and await instructions.")
    lines.push("")
  }

  // Other packets in queue
  if (data.allPackets && data.allPackets.length > 0) {
    const otherPackets = data.allPackets.filter(p => p.id !== data.currentPacket?.id)
    if (otherPackets.length > 0) {
      lines.push("## Other Packets in Queue")
      lines.push("")
      for (const packet of otherPackets) {
        const statusEmoji = packet.status === "completed" ? "[done]" :
                           packet.status === "in_progress" ? "[in progress]" :
                           "[pending]"
        lines.push(`- ${statusEmoji} ${packet.title}`)
      }
      lines.push("")
    }
  }

  // Status Reporting Instructions
  lines.push("## Status Reporting")
  lines.push("")
  lines.push("**IMPORTANT:** Report your progress to Claudia by creating status files.")
  lines.push("")
  lines.push("### How to Report Status")
  lines.push("")
  lines.push("Create JSON files in the `.claudia/status/` directory:")
  lines.push("")
  lines.push("```bash")
  lines.push("mkdir -p .claudia/status")
  lines.push("```")
  lines.push("")
  lines.push("#### Progress Update")
  lines.push("Create `.claudia/status/progress.json`:")
  lines.push("```json")
  lines.push("{")
  lines.push('  "timestamp": "2024-01-15T10:30:00Z",')
  lines.push('  "status": "in_progress",')
  lines.push('  "currentTask": "Implementing feature X",')
  lines.push('  "completedTasks": ["Task 1", "Task 2"],')
  lines.push('  "remainingTasks": ["Task 3", "Task 4"],')
  lines.push('  "blockers": [],')
  lines.push('  "notes": "Making good progress"')
  lines.push("}")
  lines.push("```")
  lines.push("")
  lines.push("#### Completion Report")
  lines.push("Create `.claudia/status/complete.json` when finished:")
  lines.push("```json")
  lines.push("{")
  lines.push('  "timestamp": "2024-01-15T11:00:00Z",')
  lines.push('  "status": "completed",')
  lines.push('  "summary": "Brief description of what was accomplished",')
  lines.push('  "filesChanged": ["src/file1.ts", "src/file2.ts"],')
  lines.push('  "testsRun": true,')
  lines.push('  "testsPassed": true,')
  lines.push('  "notes": "Ready for review"')
  lines.push("}")
  lines.push("```")
  lines.push("")
  lines.push("#### Issue or Blocker Report")
  lines.push("Create `.claudia/status/blocker.json` if stuck:")
  lines.push("```json")
  lines.push("{")
  lines.push('  "timestamp": "2024-01-15T10:45:00Z",')
  lines.push('  "status": "blocked",')
  lines.push('  "issue": "Description of the problem",')
  lines.push('  "attemptedSolutions": ["Tried X", "Tried Y"],')
  lines.push('  "needsHelp": "What kind of help is needed"')
  lines.push("}")
  lines.push("```")
  lines.push("")

  // Periodic updates
  lines.push("### Periodic Updates")
  lines.push("")
  lines.push("Update `.claudia/status/progress.json` periodically (every 5-10 minutes of work)")
  lines.push("to keep Claudia informed of your progress. This helps with:")
  lines.push("- Tracking time spent on tasks")
  lines.push("- Identifying when help is needed")
  lines.push("- Providing visibility into AI agent work")
  lines.push("")

  // Guidelines
  lines.push("## Guidelines")
  lines.push("")
  lines.push("1. **Read First:** Understand the project structure before making changes")
  lines.push("2. **Small Steps:** Make incremental changes with clear commits")
  lines.push("3. **Test:** Run tests if available before considering work complete")
  lines.push("4. **Document:** Update docs if you change behavior")
  lines.push("5. **Report:** Keep status files updated so Claudia knows your progress")
  lines.push("")

  // Footer
  lines.push("---")
  lines.push(`*Generated by Claudia at ${new Date().toISOString()}*`)
  lines.push("")

  return lines.join("\n")
}

/**
 * Check if KICKOFF.md exists
 */
async function kickoffExists(workingDirectory: string): Promise<boolean> {
  try {
    const kickoffPath = path.join(workingDirectory, "KICKOFF.md")
    const stats = await stat(kickoffPath)
    return stats.isFile()
  } catch {
    return false
  }
}

/**
 * GET /api/projects/[id]/kickoff
 * Check if KICKOFF.md exists and return its contents
 */
export async function GET(
  request: NextRequest,
  { params }: RouteParams
) {
  try {
    const { id: projectId } = await params
    const { searchParams } = new URL(request.url)
    const workingDirectory = searchParams.get("workingDirectory")

    if (!projectId) {
      return NextResponse.json(
        { error: "Project ID is required" },
        { status: 400 }
      )
    }

    if (!workingDirectory) {
      return NextResponse.json(
        { error: "workingDirectory query parameter is required" },
        { status: 400 }
      )
    }

    const kickoffPath = path.join(workingDirectory, "KICKOFF.md")
    const exists = await kickoffExists(workingDirectory)

    if (!exists) {
      return NextResponse.json({
        success: true,
        exists: false,
        projectId,
        workingDirectory,
        kickoffPath
      })
    }

    // Read the file
    const content = await fs.readFile(kickoffPath, "utf-8")
    const stats = await stat(kickoffPath)

    // ============================================
    // SECURITY: Filter KICKOFF.md for injection attempts
    // ============================================
    const filterResult = filterKickoffContent(content, {
      projectId,
      filePath: kickoffPath
    })

    // If injection patterns detected, log and optionally block
    if (filterResult.detectedPatterns.length > 0) {
      console.warn(`[kickoff] Security patterns detected in KICKOFF.md: ${kickoffPath}`)
      console.warn(`[kickoff] Patterns found:`, filterResult.detectedPatterns)

      // Log to security activity log
      logSecurityActivityEvent({
        userId: "system",
        type: "injection_attempt",
        severity: filterResult.blocked ? "critical" : "medium",
        details: {
          source: "kickoff_file",
          filePath: kickoffPath,
          projectId,
          patterns: filterResult.detectedPatterns,
          blocked: filterResult.blocked
        }
      })

      // If blocked (critical patterns), return error
      if (filterResult.blocked) {
        return NextResponse.json({
          success: false,
          exists: true,
          projectId,
          workingDirectory,
          kickoffPath,
          error: "KICKOFF.md contains potentially malicious content",
          securityWarning: "This file contains patterns that could be used for prompt injection",
          detectedPatterns: filterResult.detectedPatterns.map(p => p.pattern),
          blocked: true
        }, { status: 403 })
      }
    }

    return NextResponse.json({
      success: true,
      exists: true,
      projectId,
      workingDirectory,
      kickoffPath,
      content,
      modifiedAt: stats.mtime.toISOString(),
      // Include security info if patterns were detected but not blocked
      securityInfo: filterResult.detectedPatterns.length > 0 ? {
        warning: "Some suspicious patterns were detected but not blocked",
        patterns: filterResult.detectedPatterns.map(p => p.pattern)
      } : undefined
    })
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to check KICKOFF.md"
    console.error("[kickoff] GET error:", message)

    return NextResponse.json(
      { error: message },
      { status: 500 }
    )
  }
}

/**
 * POST /api/projects/[id]/kickoff
 * Generate/update KICKOFF.md with current project state
 *
 * Body: KickoffData
 */
export async function POST(
  request: NextRequest,
  { params }: RouteParams
) {
  try {
    const { id: projectId } = await params
    const body: KickoffData = await request.json()

    if (!projectId) {
      return NextResponse.json(
        { error: "Project ID is required" },
        { status: 400 }
      )
    }

    if (!body.workingDirectory) {
      return NextResponse.json(
        { error: "workingDirectory is required in body" },
        { status: 400 }
      )
    }

    if (!body.projectName) {
      return NextResponse.json(
        { error: "projectName is required in body" },
        { status: 400 }
      )
    }

    const { workingDirectory } = body

    // Ensure working directory exists
    try {
      await stat(workingDirectory)
    } catch {
      // Create it if it doesn't exist
      await fs.mkdir(workingDirectory, { recursive: true })
      console.log(`[kickoff] Created working directory: ${workingDirectory}`)
    }

    // Also ensure .claudia/status directory exists
    const statusDir = path.join(workingDirectory, ".claudia", "status")
    try {
      await stat(statusDir)
    } catch {
      await fs.mkdir(statusDir, { recursive: true })
      console.log(`[kickoff] Created status directory: ${statusDir}`)
    }

    // Generate KICKOFF.md content
    const content = generateKickoffContent(body)
    const kickoffPath = path.join(workingDirectory, "KICKOFF.md")

    // Write the file
    await fs.writeFile(kickoffPath, content, "utf-8")
    console.log(`[kickoff] Generated KICKOFF.md at: ${kickoffPath}`)

    return NextResponse.json({
      success: true,
      created: true,
      projectId,
      workingDirectory,
      kickoffPath,
      hasCurrentPacket: !!body.currentPacket,
      packetTitle: body.currentPacket?.title
    })
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to generate KICKOFF.md"
    console.error("[kickoff] POST error:", message)

    return NextResponse.json(
      { error: message },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/projects/[id]/kickoff
 * Remove KICKOFF.md (optional cleanup)
 */
export async function DELETE(
  request: NextRequest,
  { params }: RouteParams
) {
  try {
    const { id: projectId } = await params
    const { searchParams } = new URL(request.url)
    const workingDirectory = searchParams.get("workingDirectory")

    if (!projectId) {
      return NextResponse.json(
        { error: "Project ID is required" },
        { status: 400 }
      )
    }

    if (!workingDirectory) {
      return NextResponse.json(
        { error: "workingDirectory query parameter is required" },
        { status: 400 }
      )
    }

    const kickoffPath = path.join(workingDirectory, "KICKOFF.md")
    const exists = await kickoffExists(workingDirectory)

    if (!exists) {
      return NextResponse.json({
        success: true,
        deleted: false,
        message: "KICKOFF.md does not exist"
      })
    }

    await fs.unlink(kickoffPath)
    console.log(`[kickoff] Deleted KICKOFF.md at: ${kickoffPath}`)

    return NextResponse.json({
      success: true,
      deleted: true,
      kickoffPath
    })
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to delete KICKOFF.md"
    console.error("[kickoff] DELETE error:", message)

    return NextResponse.json(
      { error: message },
      { status: 500 }
    )
  }
}
