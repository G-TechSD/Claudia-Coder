[
  {
    "updatedAt": "2026-01-08T04:35:43.926Z",
    "createdAt": "2026-01-08T04:35:43.926Z",
    "id": "1XW5Q3fwUoM9RCSC",
    "name": "Claudia Execute Webhook (Simple)",
    "active": false,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "claudia-execute",
          "responseMode": "responseNode",
          "options": {}
        },
        "id": "webhook-exec",
        "name": "Webhook Trigger",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          240,
          300
        ],
        "webhookId": "claudia-execute"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ status: \"accepted\", packet_id: \"PKT-\" + Date.now(), message: \"Webhook received. Processing will be implemented.\", received_at: new Date().toISOString(), data: $json }) }}",
          "options": {
            "responseCode": 202
          }
        },
        "id": "respond-accepted",
        "name": "Respond Accepted",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          460,
          300
        ]
      }
    ],
    "connections": {
      "Webhook Trigger": {
        "main": [
          [
            {
              "node": "Respond Accepted",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "e96b05d5-b0c8-47b3-931a-6f068e4a4c6e",
    "activeVersionId": null,
    "triggerCount": 0,
    "shared": [
      {
        "updatedAt": "2026-01-08T04:35:43.929Z",
        "createdAt": "2026-01-08T04:35:43.929Z",
        "role": "workflow:owner",
        "workflowId": "1XW5Q3fwUoM9RCSC",
        "projectId": "CDNyPtsGxHdhfdhy"
      }
    ],
    "activeVersion": null,
    "tags": []
  },
  {
    "updatedAt": "2026-01-08T04:35:53.268Z",
    "createdAt": "2026-01-08T04:35:53.268Z",
    "id": "3jGHJYTu4PhPw8X9",
    "name": "Claudia Execute Webhook (Working)",
    "active": true,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "claudia-execute",
          "responseMode": "responseNode",
          "options": {}
        },
        "id": "webhook-exec",
        "name": "Webhook Trigger",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          240,
          300
        ],
        "webhookId": "claudia-execute"
      },
      {
        "parameters": {
          "respondWith": "allIncomingItems",
          "options": {
            "responseCode": 202
          }
        },
        "id": "respond-accepted",
        "name": "Respond Accepted",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          460,
          300
        ]
      }
    ],
    "connections": {
      "Webhook Trigger": {
        "main": [
          [
            {
              "node": "Respond Accepted",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "333aeb9b-7859-4c14-98d7-61e696cd88ad",
    "activeVersionId": "333aeb9b-7859-4c14-98d7-61e696cd88ad",
    "triggerCount": 1,
    "shared": [
      {
        "updatedAt": "2026-01-08T04:35:53.272Z",
        "createdAt": "2026-01-08T04:35:53.272Z",
        "role": "workflow:owner",
        "workflowId": "3jGHJYTu4PhPw8X9",
        "projectId": "CDNyPtsGxHdhfdhy"
      }
    ],
    "activeVersion": {
      "updatedAt": "2026-01-08T04:35:53.284Z",
      "createdAt": "2026-01-08T04:35:53.284Z",
      "versionId": "333aeb9b-7859-4c14-98d7-61e696cd88ad",
      "workflowId": "3jGHJYTu4PhPw8X9",
      "nodes": [
        {
          "parameters": {
            "httpMethod": "POST",
            "path": "claudia-execute",
            "responseMode": "responseNode",
            "options": {}
          },
          "id": "webhook-exec",
          "name": "Webhook Trigger",
          "type": "n8n-nodes-base.webhook",
          "typeVersion": 2,
          "position": [
            240,
            300
          ],
          "webhookId": "claudia-execute"
        },
        {
          "parameters": {
            "respondWith": "allIncomingItems",
            "options": {
              "responseCode": 202
            }
          },
          "id": "respond-accepted",
          "name": "Respond Accepted",
          "type": "n8n-nodes-base.respondToWebhook",
          "typeVersion": 1,
          "position": [
            460,
            300
          ]
        }
      ],
      "connections": {
        "Webhook Trigger": {
          "main": [
            [
              {
                "node": "Respond Accepted",
                "type": "main",
                "index": 0
              }
            ]
          ]
        }
      },
      "authors": "Bill Griffith",
      "name": null,
      "description": null
    },
    "tags": []
  },
  {
    "updatedAt": "2026-01-08T04:35:05.777Z",
    "createdAt": "2026-01-08T04:35:05.777Z",
    "id": "5nyJPfrirOtbczoS",
    "name": "Claudia Simple Webhook Test",
    "active": true,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "claudia-test",
          "responseMode": "responseNode",
          "options": {}
        },
        "id": "webhook-test",
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          240,
          300
        ],
        "webhookId": "claudia-test"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ success: true, received: $json, timestamp: new Date().toISOString() }) }}",
          "options": {
            "responseCode": 200
          }
        },
        "id": "respond",
        "name": "Respond",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          460,
          300
        ]
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Respond",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "c17cc71a-9560-4c50-9379-21895e27498e",
    "activeVersionId": "c17cc71a-9560-4c50-9379-21895e27498e",
    "triggerCount": 1,
    "shared": [
      {
        "updatedAt": "2026-01-08T04:35:05.779Z",
        "createdAt": "2026-01-08T04:35:05.779Z",
        "role": "workflow:owner",
        "workflowId": "5nyJPfrirOtbczoS",
        "projectId": "CDNyPtsGxHdhfdhy"
      }
    ],
    "activeVersion": {
      "updatedAt": "2026-01-08T04:35:05.789Z",
      "createdAt": "2026-01-08T04:35:05.789Z",
      "versionId": "c17cc71a-9560-4c50-9379-21895e27498e",
      "workflowId": "5nyJPfrirOtbczoS",
      "nodes": [
        {
          "parameters": {
            "httpMethod": "POST",
            "path": "claudia-test",
            "responseMode": "responseNode",
            "options": {}
          },
          "id": "webhook-test",
          "name": "Webhook",
          "type": "n8n-nodes-base.webhook",
          "typeVersion": 2,
          "position": [
            240,
            300
          ],
          "webhookId": "claudia-test"
        },
        {
          "parameters": {
            "respondWith": "json",
            "responseBody": "={{ JSON.stringify({ success: true, received: $json, timestamp: new Date().toISOString() }) }}",
            "options": {
              "responseCode": 200
            }
          },
          "id": "respond",
          "name": "Respond",
          "type": "n8n-nodes-base.respondToWebhook",
          "typeVersion": 1,
          "position": [
            460,
            300
          ]
        }
      ],
      "connections": {
        "Webhook": {
          "main": [
            [
              {
                "node": "Respond",
                "type": "main",
                "index": 0
              }
            ]
          ]
        }
      },
      "authors": "Bill Griffith",
      "name": null,
      "description": null
    },
    "tags": []
  },
  {
    "updatedAt": "2026-01-08T04:33:54.708Z",
    "createdAt": "2026-01-08T04:33:54.708Z",
    "id": "AR1QJPBsX746UQgu",
    "name": "Claudia Webhook (No Auth) - Testing",
    "active": true,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "claudia-execute-noauth",
          "options": {
            "rawBody": false,
            "responseCode": 202,
            "responseData": "firstEntryJson"
          }
        },
        "id": "webhook-claudia-execute",
        "name": "Webhook: /claudia-execute",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          240,
          300
        ],
        "webhookId": "claudia-execute-noauth",
        "notes": "Main entry point for Claudia to submit work packets. Endpoint: POST /webhook/claudia-execute"
      },
      {
        "parameters": {
          "jsCode": "// Validate and normalize incoming packet from Claudia\nconst input = $input.first().json;\nconst headers = $input.first().json.headers || {};\nconst body = input.body || input;\n\n// Generate packet ID if not provided\nconst packetId = body.packet_id || body.packetID || `PKT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n// Validate required fields\nconst errors = [];\nif (!body.title && !body.description && !body.issue_id) {\n  errors.push('At least one of title, description, or issue_id is required');\n}\n\nif (errors.length > 0) {\n  return {\n    json: {\n      success: false,\n      error: 'Validation failed',\n      errors: errors,\n      packet_id: packetId,\n      received_at: new Date().toISOString()\n    }\n  };\n}\n\n// Normalize the packet structure\nconst normalizedPacket = {\n  packet_id: packetId,\n  issue_id: body.issue_id || body.issueID || null,\n  title: body.title || 'Untitled Task',\n  description: body.description || body.summary || '',\n  labels: body.labels || [],\n  priority: body.priority || 'medium',\n  project_context: body.project_context || body.projectContext || '',\n  callback_url: body.callback_url || body.callbackUrl || null,\n  callback_method: body.callback_method || 'POST',\n  assigned_worker: body.assigned_worker || body.assignedWorker || 'worker_bee_gptoss',\n  project_id: body.project_id || body.projectID || null,\n  metadata: {\n    source: 'claudia_webhook',\n    received_at: new Date().toISOString(),\n    request_headers: {\n      user_agent: headers['user-agent'] || 'unknown',\n      x_request_id: headers['x-request-id'] || packetId\n    }\n  },\n  \n  // Processing state\n  phase: 'initial_implementation',\n  status: 'queued',\n  retry_count: body.retry_count || 0,\n  previous_attempts: body.previous_attempts || [],\n  \n  // Quality loop configuration\n  quality_config: {\n    max_retries: body.max_retries || 3,\n    validation_required: body.validation_required !== false,\n    auto_iterate: body.auto_iterate !== false,\n    callback_on_progress: body.callback_on_progress || false,\n    callback_on_complete: body.callback_on_complete !== false\n  }\n};\n\nreturn {\n  json: {\n    success: true,\n    message: 'Packet accepted for processing',\n    packet: normalizedPacket\n  }\n};"
        },
        "id": "validate-packet",
        "name": "Validate & Normalize Packet",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          460,
          300
        ],
        "notes": "Validates incoming packet and normalizes structure for processing"
      },
      {
        "parameters": {
          "conditions": {
            "boolean": [
              {
                "value1": "={{ $json.success }}",
                "value2": true
              }
            ]
          }
        },
        "id": "check-validation",
        "name": "Validation Passed?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          680,
          300
        ],
        "notes": "Route valid packets to processing, invalid to error response"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ success: false, error: $json.error, errors: $json.errors, packet_id: $json.packet_id }) }}",
          "options": {
            "responseCode": 400
          }
        },
        "id": "respond-validation-error",
        "name": "Respond: Validation Error",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          900,
          500
        ],
        "notes": "Return 400 Bad Request for invalid packets"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ success: true, message: 'Packet accepted for processing', packet_id: $json.packet.packet_id, status: 'queued', callback_url: $json.packet.callback_url || 'none configured' }) }}",
          "options": {
            "responseCode": 202
          }
        },
        "id": "respond-accepted",
        "name": "Respond: Accepted (202)",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          900,
          200
        ],
        "notes": "Return 202 Accepted - packet will be processed asynchronously"
      },
      {
        "parameters": {
          "jsCode": "// Store packet in processing queue\nconst packet = $input.first().json.packet;\n\nreturn {\n  json: {\n    packet_id: packet.packet_id,\n    issue_id: packet.issue_id,\n    title: packet.title,\n    description: packet.description,\n    labels: packet.labels,\n    priority: packet.priority,\n    project_context: packet.project_context,\n    callback_url: packet.callback_url,\n    assigned_worker: packet.assigned_worker,\n    phase: packet.phase,\n    status: 'processing',\n    retry_count: packet.retry_count,\n    quality_config: packet.quality_config,\n    metadata: packet.metadata,\n    processing_started_at: new Date().toISOString()\n  }\n};"
        },
        "id": "prepare-for-processing",
        "name": "Prepare for Processing",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1120,
          200
        ],
        "notes": "Prepare packet for quality loop processing"
      },
      {
        "parameters": {
          "jsCode": "// Send progress callback if configured\nconst packet = $input.first().json;\n\nif (!packet.callback_url) {\n  return { json: { ...packet, progress_callback_skipped: true } };\n}\n\nif (!packet.quality_config.callback_on_progress) {\n  return { json: { ...packet, progress_callback_skipped: true } };\n}\n\nreturn {\n  json: {\n    ...packet,\n    progress_callback: {\n      should_send: true,\n      url: packet.callback_url,\n      payload: {\n        type: 'progress',\n        packet_id: packet.packet_id,\n        phase: packet.phase,\n        status: packet.status,\n        message: 'Processing started',\n        timestamp: new Date().toISOString()\n      }\n    }\n  }\n};"
        },
        "id": "check-progress-callback",
        "name": "Check Progress Callback",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1340,
          200
        ],
        "notes": "Determine if progress callback should be sent"
      },
      {
        "parameters": {
          "conditions": {
            "boolean": [
              {
                "value1": "={{ $json.progress_callback?.should_send === true }}",
                "value2": true
              }
            ]
          }
        },
        "id": "should-send-progress",
        "name": "Send Progress Callback?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          1560,
          200
        ],
        "notes": "Route to callback sender if configured"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $json.progress_callback.url }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "X-Claudia-Callback",
                "value": "progress"
              },
              {
                "name": "X-Packet-ID",
                "value": "={{ $json.packet_id }}"
              }
            ]
          },
          "sendBody": true,
          "bodyParameters": {
            "parameters": [
              {
                "name": "",
                "value": "={{ $json.progress_callback.payload }}"
              }
            ]
          },
          "options": {
            "timeout": 10000,
            "allowUnauthorizedCerts": true
          }
        },
        "id": "send-progress-callback",
        "name": "Send Progress Callback",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1780,
          100
        ],
        "notes": "Send progress notification to Claudia callback URL"
      },
      {
        "parameters": {},
        "id": "merge-progress-paths",
        "name": "Merge Progress Paths",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 2.1,
        "position": [
          2000,
          200
        ],
        "notes": "Merge paths after optional progress callback"
      },
      {
        "parameters": {
          "jsCode": "// Build comprehensive prompt for implementation\nconst packet = $input.first().json;\n\nconst systemPrompt = `You are an expert software engineer working on a development task.\n\n## Project Context\n${packet.project_context || 'No specific project context provided.'}\n\n## Your Task\nImplement the following feature completely and correctly.\n\n## IMPORTANT REQUIREMENTS\n1. Write production-ready code with proper error handling\n2. Include comprehensive type hints and documentation  \n3. Write pytest tests that actually validate correctness\n4. Use modern Python best practices (3.11+)\n5. Include edge case handling\n6. No placeholder or TODO comments\n7. All dependencies must be clearly specified\n8. Code must be self-contained and runnable\n\n## DO NOT\n- Use deprecated APIs\n- Make unverified claims about \"production-ready\" code\n- Include logic errors or untested edge cases\n- Use in-memory stores without documenting limitations\n- Skip error handling\n\nIf you're unsure about an implementation detail, state your assumptions clearly.`;\n\nconst userPrompt = `# Task: ${packet.title}\n\n## Description\n${packet.description}\n\n## Requirements\n- Provide complete file structure\n- Include all necessary imports\n- Write comprehensive tests\n- Document assumptions and limitations\n- Specify exact dependency versions\n\n## Labels/Context\n${Array.isArray(packet.labels) ? packet.labels.join(', ') : 'None'}\n\n## Priority\n${packet.priority}\n\n## Deliver\n1. Complete implementation with file structure\n2. Test suite with coverage\n3. README with setup instructions\n4. requirements.txt or pyproject.toml\n5. Metadata section with assumptions and next steps`;\n\nreturn {\n  json: {\n    ...packet,\n    prompts: {\n      system: systemPrompt,\n      user: userPrompt\n    },\n    model_config: {\n      model: 'gpt-oss-20b',\n      temperature: 0.3,\n      max_tokens: 8000\n    }\n  }\n};"
        },
        "id": "build-implementation-prompt",
        "name": "Build Implementation Prompt",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2220,
          200
        ],
        "notes": "Create detailed prompt with context and requirements"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $env.LLM_API_ENDPOINT || 'http://192.168.245.200:1234' }}/v1/chat/completions",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { model: $json.model_config.model, messages: [{role: 'system', content: $json.prompts.system}, {role: 'user', content: $json.prompts.user}], temperature: $json.model_config.temperature, max_tokens: $json.model_config.max_tokens } }}",
          "options": {
            "timeout": 300000
          }
        },
        "id": "execute-implementation",
        "name": "Execute Implementation (LLM)",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          2440,
          200
        ],
        "notes": "Generate implementation using local LLM"
      },
      {
        "parameters": {
          "jsCode": "// Extract and format the implementation output\nconst item = $input.first();\nconst response = item.json.choices?.[0]?.message?.content || 'Error: No response from LLM';\nconst metadata = $node[\"Build Implementation Prompt\"].json;\n\nconst timestamp = new Date().toISOString();\nconst outputFilename = `${metadata.packet_id}-implementation-${Date.now()}.md`;\n\nreturn {\n  json: {\n    ...metadata,\n    implementation: {\n      raw_output: response,\n      timestamp: timestamp,\n      filename: outputFilename,\n      model: metadata.model_config.model,\n      phase: 'validation'\n    }\n  }\n};"
        },
        "id": "format-implementation",
        "name": "Format Implementation Output",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2660,
          200
        ],
        "notes": "Extract response and prepare for validation"
      },
      {
        "parameters": {
          "jsCode": "// Build validation prompt for code review\nconst item = $input.first().json;\nconst implementation = item.implementation.raw_output;\n\nconst validationPrompt = `You are a senior software architect conducting a thorough code review.\n\nEvaluate this implementation against these criteria:\n\n## Code Quality Checklist\n1. **Correctness**: Logic errors, off-by-one errors, incorrect algorithms\n2. **Security**: Vulnerabilities, injection risks, insecure crypto\n3. **Testing**: Test coverage, edge cases, assertion quality\n4. **Dependencies**: Version specificity, deprecated APIs, compatibility\n5. **Error Handling**: Missing try/catch, unhandled edge cases\n6. **Documentation**: Accuracy of claims, missing assumptions\n7. **Best Practices**: Code smells, anti-patterns, maintainability\n8. **Completeness**: Missing files, incomplete implementations\n\n## Implementation to Review\n\n\\`\\`\\`markdown\n${implementation.substring(0, 15000)}\n\\`\\`\\`\n\n## Required Output Format\n\nProvide your evaluation as JSON:\n\n\\`\\`\\`json\n{\n  \"overall_quality_score\": <0-100>,\n  \"recommendation\": \"ACCEPT\" | \"ITERATE\" | \"REJECT\",\n  \"critical_issues\": [\n    {\"severity\": \"critical|major|minor\", \"category\": \"correctness|security|testing|etc\", \"description\": \"...\", \"location\": \"file:line or general\"}\n  ],\n  \"strengths\": [\"...\"],\n  \"weaknesses\": [\"...\"],\n  \"action_items\": [\n    {\"priority\": \"high|medium|low\", \"task\": \"...\", \"rationale\": \"...\"}\n  ],\n  \"direction_assessment\": \"Does this align with project goals? Explain.\",\n  \"suggested_next_steps\": [\"...\"]\n}\n\\`\\`\\`\n\nBe thorough and honest. Production systems depend on this evaluation.`;\n\nreturn {\n  json: {\n    ...item,\n    validation_prompt: validationPrompt\n  }\n};"
        },
        "id": "build-validation-prompt",
        "name": "Build Validation Prompt",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2880,
          200
        ],
        "notes": "Prepare comprehensive code review prompt"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.anthropic.com/v1/messages",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "anthropic-version",
                "value": "2023-06-01"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { model: 'claude-sonnet-4-20250514', max_tokens: 4096, messages: [{role: 'user', content: $json.validation_prompt}] } }}",
          "options": {
            "timeout": 180000
          }
        },
        "id": "execute-validation",
        "name": "Execute Validation (Claude)",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          3100,
          200
        ],
        "notes": "Use Claude for high-quality code review. Configure with Anthropic credential."
      },
      {
        "parameters": {
          "jsCode": "// Parse validation results\nconst item = $input.first();\nconst validationText = item.json.content?.[0]?.text || '';\n\n// Extract JSON from markdown code block\nconst jsonMatch = validationText.match(/```json\\n([\\s\\S]*?)\\n```/);\nlet validation;\n\nif (jsonMatch) {\n  try {\n    validation = JSON.parse(jsonMatch[1]);\n  } catch (e) {\n    validation = {\n      overall_quality_score: 50,\n      recommendation: 'ITERATE',\n      critical_issues: [{\n        severity: 'minor',\n        category: 'validation_parsing',\n        description: 'Could not parse validation JSON, will iterate',\n        location: 'validation'\n      }],\n      error: e.message\n    };\n  }\n} else {\n  // Fallback: try to parse entire response\n  try {\n    validation = JSON.parse(validationText);\n  } catch (e) {\n    // If parsing fails, create error structure\n    validation = {\n      overall_quality_score: 50,\n      recommendation: 'ITERATE',\n      critical_issues: [{\n        severity: 'minor',\n        category: 'validation_error',\n        description: 'Failed to parse validation response',\n        location: 'validation'\n      }],\n      error: e.message,\n      raw_response: validationText.substring(0, 500)\n    };\n  }\n}\n\nconst metadata = $node[\"Build Validation Prompt\"].json;\n\nreturn {\n  json: {\n    ...metadata,\n    validation: validation,\n    next_phase: validation.recommendation === 'ACCEPT' ? 'complete' : \n                validation.recommendation === 'ITERATE' ? 'iteration' : 'correction'\n  }\n};"
        },
        "id": "parse-validation",
        "name": "Parse Validation Results",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3320,
          200
        ],
        "notes": "Extract and parse JSON validation results"
      },
      {
        "parameters": {
          "rules": {
            "values": [
              {
                "conditions": {
                  "string": [
                    {
                      "value1": "={{ $json.validation.recommendation }}",
                      "operation": "equals",
                      "value2": "ACCEPT"
                    }
                  ]
                },
                "output": 0
              },
              {
                "conditions": {
                  "string": [
                    {
                      "value1": "={{ $json.validation.recommendation }}",
                      "operation": "equals",
                      "value2": "ITERATE"
                    }
                  ]
                },
                "output": 1
              },
              {
                "conditions": {
                  "string": [
                    {
                      "value1": "={{ $json.validation.recommendation }}",
                      "operation": "equals",
                      "value2": "REJECT"
                    }
                  ]
                },
                "output": 2
              }
            ]
          }
        },
        "id": "decision-router",
        "name": "Route by Decision",
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3,
        "position": [
          3540,
          200
        ],
        "notes": "Route based on validation recommendation: ACCEPT, ITERATE, or REJECT"
      },
      {
        "parameters": {
          "jsCode": "// ACCEPT: Prepare final result for callback\nconst item = $input.first().json;\n\nreturn {\n  json: {\n    packet_id: item.packet_id,\n    issue_id: item.issue_id,\n    title: item.title,\n    status: 'completed',\n    recommendation: 'ACCEPT',\n    quality_score: item.validation.overall_quality_score,\n    implementation: item.implementation,\n    validation: {\n      overall_quality_score: item.validation.overall_quality_score,\n      strengths: item.validation.strengths,\n      weaknesses: item.validation.weaknesses,\n      suggested_next_steps: item.validation.suggested_next_steps\n    },\n    callback_url: item.callback_url,\n    should_callback: item.quality_config.callback_on_complete && !!item.callback_url,\n    completed_at: new Date().toISOString()\n  }\n};"
        },
        "id": "prepare-accept-result",
        "name": "Prepare Accept Result",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3760,
          0
        ],
        "notes": "ACCEPT path: Prepare successful completion result"
      },
      {
        "parameters": {
          "jsCode": "// ITERATE: Check retry count and prepare for iteration\nconst item = $input.first().json;\nconst maxRetries = item.quality_config.max_retries || 3;\nconst currentRetry = item.retry_count || 0;\n\nif (currentRetry >= maxRetries || !item.quality_config.auto_iterate) {\n  // Max retries reached or auto-iterate disabled - return as partial success\n  return {\n    json: {\n      packet_id: item.packet_id,\n      issue_id: item.issue_id,\n      title: item.title,\n      status: 'completed_with_issues',\n      recommendation: 'ITERATE',\n      quality_score: item.validation.overall_quality_score,\n      implementation: item.implementation,\n      validation: item.validation,\n      callback_url: item.callback_url,\n      should_callback: item.quality_config.callback_on_complete && !!item.callback_url,\n      retry_count: currentRetry,\n      max_retries_reached: currentRetry >= maxRetries,\n      completed_at: new Date().toISOString()\n    }\n  };\n}\n\n// Prepare for iteration with improved prompt\nconst iterationNotes = item.validation.action_items\n  .filter(a => a.priority === 'high' || a.priority === 'medium')\n  .map(a => `- ${a.task}: ${a.rationale}`)\n  .join('\\n');\n\nreturn {\n  json: {\n    ...item,\n    status: 'iterating',\n    retry_count: currentRetry + 1,\n    iteration_notes: iterationNotes,\n    should_iterate: true\n  }\n};"
        },
        "id": "handle-iterate",
        "name": "Handle Iterate Decision",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3760,
          200
        ],
        "notes": "ITERATE path: Check retry limits and prepare iteration"
      },
      {
        "parameters": {
          "jsCode": "// REJECT: Prepare failure result\nconst item = $input.first().json;\n\nreturn {\n  json: {\n    packet_id: item.packet_id,\n    issue_id: item.issue_id,\n    title: item.title,\n    status: 'failed',\n    recommendation: 'REJECT',\n    quality_score: item.validation.overall_quality_score,\n    implementation: item.implementation,\n    validation: {\n      overall_quality_score: item.validation.overall_quality_score,\n      critical_issues: item.validation.critical_issues,\n      direction_assessment: item.validation.direction_assessment,\n      action_items: item.validation.action_items\n    },\n    callback_url: item.callback_url,\n    should_callback: item.quality_config.callback_on_complete && !!item.callback_url,\n    retry_count: item.retry_count,\n    failed_at: new Date().toISOString()\n  }\n};"
        },
        "id": "prepare-reject-result",
        "name": "Prepare Reject Result",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3760,
          400
        ],
        "notes": "REJECT path: Prepare failure result with details"
      },
      {
        "parameters": {
          "conditions": {
            "boolean": [
              {
                "value1": "={{ $json.should_iterate === true }}",
                "value2": true
              }
            ]
          }
        },
        "id": "check-should-iterate",
        "name": "Should Iterate?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          3980,
          200
        ],
        "notes": "Check if we should loop back for iteration"
      },
      {
        "parameters": {},
        "id": "merge-final-results",
        "name": "Merge Final Results",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 2.1,
        "position": [
          4200,
          300
        ],
        "notes": "Combine all paths that don't iterate"
      },
      {
        "parameters": {
          "conditions": {
            "boolean": [
              {
                "value1": "={{ $json.should_callback === true }}",
                "value2": true
              }
            ]
          }
        },
        "id": "check-should-callback",
        "name": "Should Send Callback?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          4420,
          300
        ],
        "notes": "Determine if callback should be sent to Claudia"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $json.callback_url }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "X-Claudia-Callback",
                "value": "completion"
              },
              {
                "name": "X-Packet-ID",
                "value": "={{ $json.packet_id }}"
              },
              {
                "name": "X-Status",
                "value": "={{ $json.status }}"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { type: 'completion', packet_id: $json.packet_id, issue_id: $json.issue_id, title: $json.title, status: $json.status, recommendation: $json.recommendation, quality_score: $json.quality_score, implementation: { output: $json.implementation.raw_output, model: $json.implementation.model, timestamp: $json.implementation.timestamp }, validation: $json.validation, retry_count: $json.retry_count || 0, completed_at: $json.completed_at || $json.failed_at } }}",
          "options": {
            "timeout": 30000,
            "allowUnauthorizedCerts": true
          }
        },
        "id": "send-completion-callback",
        "name": "Send Completion Callback",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          4640,
          200
        ],
        "notes": "Send final results back to Claudia's callback URL"
      },
      {
        "parameters": {},
        "id": "merge-callback-paths",
        "name": "Merge Callback Paths",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 2.1,
        "position": [
          4860,
          300
        ],
        "notes": "Merge after optional callback"
      },
      {
        "parameters": {
          "jsCode": "// Generate final execution summary\nconst item = $input.first().json;\n\nconst summary = {\n  execution_id: `EXEC-${Date.now()}`,\n  packet_id: item.packet_id || 'unknown',\n  issue_id: item.issue_id || null,\n  title: item.title || 'Unknown Task',\n  final_status: item.status || 'unknown',\n  recommendation: item.recommendation || 'N/A',\n  quality_score: item.quality_score || item.validation?.overall_quality_score || 0,\n  retries_used: item.retry_count || 0,\n  callback_sent: item.should_callback || false,\n  callback_url: item.callback_url || null,\n  completed_at: item.completed_at || item.failed_at || new Date().toISOString(),\n  processing_duration_estimate: 'See N8N execution logs for precise timing'\n};\n\nreturn { json: summary };"
        },
        "id": "generate-summary",
        "name": "Generate Summary",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5080,
          300
        ],
        "notes": "Create execution summary for logging"
      },
      {
        "parameters": {
          "jsCode": "// Prepare iteration packet - loops back to implementation\nconst item = $input.first().json;\n\nconst improvedPrompt = `ITERATION #${item.retry_count}\n\nThe previous implementation attempt needs improvement.\n\n## Feedback from Code Review:\n${item.iteration_notes}\n\n## Quality Score: ${item.validation.overall_quality_score}/100\n\n## Critical Issues to Address:\n${(item.validation.critical_issues || []).map(i => `- [${i.severity}] ${i.category}: ${i.description}`).join('\\n')}\n\n## Original Requirements:\n${item.prompts.user}\n\n---\n\nPlease provide an IMPROVED implementation that:\n1. Addresses ALL the critical issues listed above\n2. Maintains all working aspects from the previous attempt\n3. Follows the specific action items from the review\n\nProvide the complete improved implementation.`;\n\nreturn {\n  json: {\n    ...item,\n    prompts: {\n      system: item.prompts.system,\n      user: improvedPrompt\n    },\n    phase: 'iteration',\n    model_config: {\n      model: item.model_config.model,\n      temperature: 0.2,  // Lower temperature for corrections\n      max_tokens: item.model_config.max_tokens\n    }\n  }\n};"
        },
        "id": "prepare-iteration",
        "name": "Prepare Iteration",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3980,
          100
        ],
        "notes": "Build improved prompt for iteration attempt"
      }
    ],
    "connections": {
      "Webhook: /claudia-execute": {
        "main": [
          [
            {
              "node": "Validate & Normalize Packet",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate & Normalize Packet": {
        "main": [
          [
            {
              "node": "Validation Passed?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validation Passed?": {
        "main": [
          [
            {
              "node": "Respond: Accepted (202)",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Respond: Validation Error",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Respond: Accepted (202)": {
        "main": [
          [
            {
              "node": "Prepare for Processing",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare for Processing": {
        "main": [
          [
            {
              "node": "Check Progress Callback",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Progress Callback": {
        "main": [
          [
            {
              "node": "Send Progress Callback?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Progress Callback?": {
        "main": [
          [
            {
              "node": "Send Progress Callback",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Merge Progress Paths",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Send Progress Callback": {
        "main": [
          [
            {
              "node": "Merge Progress Paths",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Progress Paths": {
        "main": [
          [
            {
              "node": "Build Implementation Prompt",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Implementation Prompt": {
        "main": [
          [
            {
              "node": "Execute Implementation (LLM)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Implementation (LLM)": {
        "main": [
          [
            {
              "node": "Format Implementation Output",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format Implementation Output": {
        "main": [
          [
            {
              "node": "Build Validation Prompt",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Validation Prompt": {
        "main": [
          [
            {
              "node": "Execute Validation (Claude)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Validation (Claude)": {
        "main": [
          [
            {
              "node": "Parse Validation Results",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Validation Results": {
        "main": [
          [
            {
              "node": "Route by Decision",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Route by Decision": {
        "main": [
          [
            {
              "node": "Prepare Accept Result",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Handle Iterate Decision",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Prepare Reject Result",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Accept Result": {
        "main": [
          [
            {
              "node": "Merge Final Results",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Handle Iterate Decision": {
        "main": [
          [
            {
              "node": "Check Should Iterate?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Should Iterate?": {
        "main": [
          [
            {
              "node": "Prepare Iteration",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Merge Final Results",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Prepare Reject Result": {
        "main": [
          [
            {
              "node": "Merge Final Results",
              "type": "main",
              "index": 2
            }
          ]
        ]
      },
      "Merge Final Results": {
        "main": [
          [
            {
              "node": "Should Send Callback?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Should Send Callback?": {
        "main": [
          [
            {
              "node": "Send Completion Callback",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Merge Callback Paths",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Send Completion Callback": {
        "main": [
          [
            {
              "node": "Merge Callback Paths",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Callback Paths": {
        "main": [
          [
            {
              "node": "Generate Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Iteration": {
        "main": [
          [
            {
              "node": "Execute Implementation (LLM)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1",
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "0d7b8d87-2415-4801-bec2-47daa8169719",
    "activeVersionId": "0d7b8d87-2415-4801-bec2-47daa8169719",
    "triggerCount": 1,
    "shared": [
      {
        "updatedAt": "2026-01-08T04:33:54.713Z",
        "createdAt": "2026-01-08T04:33:54.713Z",
        "role": "workflow:owner",
        "workflowId": "AR1QJPBsX746UQgu",
        "projectId": "CDNyPtsGxHdhfdhy"
      }
    ],
    "activeVersion": {
      "updatedAt": "2026-01-08T04:33:54.730Z",
      "createdAt": "2026-01-08T04:33:54.730Z",
      "versionId": "0d7b8d87-2415-4801-bec2-47daa8169719",
      "workflowId": "AR1QJPBsX746UQgu",
      "nodes": [
        {
          "parameters": {
            "httpMethod": "POST",
            "path": "claudia-execute-noauth",
            "options": {
              "rawBody": false,
              "responseCode": 202,
              "responseData": "firstEntryJson"
            }
          },
          "id": "webhook-claudia-execute",
          "name": "Webhook: /claudia-execute",
          "type": "n8n-nodes-base.webhook",
          "typeVersion": 2,
          "position": [
            240,
            300
          ],
          "webhookId": "claudia-execute-noauth",
          "notes": "Main entry point for Claudia to submit work packets. Endpoint: POST /webhook/claudia-execute"
        },
        {
          "parameters": {
            "jsCode": "// Validate and normalize incoming packet from Claudia\nconst input = $input.first().json;\nconst headers = $input.first().json.headers || {};\nconst body = input.body || input;\n\n// Generate packet ID if not provided\nconst packetId = body.packet_id || body.packetID || `PKT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n// Validate required fields\nconst errors = [];\nif (!body.title && !body.description && !body.issue_id) {\n  errors.push('At least one of title, description, or issue_id is required');\n}\n\nif (errors.length > 0) {\n  return {\n    json: {\n      success: false,\n      error: 'Validation failed',\n      errors: errors,\n      packet_id: packetId,\n      received_at: new Date().toISOString()\n    }\n  };\n}\n\n// Normalize the packet structure\nconst normalizedPacket = {\n  packet_id: packetId,\n  issue_id: body.issue_id || body.issueID || null,\n  title: body.title || 'Untitled Task',\n  description: body.description || body.summary || '',\n  labels: body.labels || [],\n  priority: body.priority || 'medium',\n  project_context: body.project_context || body.projectContext || '',\n  callback_url: body.callback_url || body.callbackUrl || null,\n  callback_method: body.callback_method || 'POST',\n  assigned_worker: body.assigned_worker || body.assignedWorker || 'worker_bee_gptoss',\n  project_id: body.project_id || body.projectID || null,\n  metadata: {\n    source: 'claudia_webhook',\n    received_at: new Date().toISOString(),\n    request_headers: {\n      user_agent: headers['user-agent'] || 'unknown',\n      x_request_id: headers['x-request-id'] || packetId\n    }\n  },\n  \n  // Processing state\n  phase: 'initial_implementation',\n  status: 'queued',\n  retry_count: body.retry_count || 0,\n  previous_attempts: body.previous_attempts || [],\n  \n  // Quality loop configuration\n  quality_config: {\n    max_retries: body.max_retries || 3,\n    validation_required: body.validation_required !== false,\n    auto_iterate: body.auto_iterate !== false,\n    callback_on_progress: body.callback_on_progress || false,\n    callback_on_complete: body.callback_on_complete !== false\n  }\n};\n\nreturn {\n  json: {\n    success: true,\n    message: 'Packet accepted for processing',\n    packet: normalizedPacket\n  }\n};"
          },
          "id": "validate-packet",
          "name": "Validate & Normalize Packet",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            460,
            300
          ],
          "notes": "Validates incoming packet and normalizes structure for processing"
        },
        {
          "parameters": {
            "conditions": {
              "boolean": [
                {
                  "value1": "={{ $json.success }}",
                  "value2": true
                }
              ]
            }
          },
          "id": "check-validation",
          "name": "Validation Passed?",
          "type": "n8n-nodes-base.if",
          "typeVersion": 2,
          "position": [
            680,
            300
          ],
          "notes": "Route valid packets to processing, invalid to error response"
        },
        {
          "parameters": {
            "respondWith": "json",
            "responseBody": "={{ JSON.stringify({ success: false, error: $json.error, errors: $json.errors, packet_id: $json.packet_id }) }}",
            "options": {
              "responseCode": 400
            }
          },
          "id": "respond-validation-error",
          "name": "Respond: Validation Error",
          "type": "n8n-nodes-base.respondToWebhook",
          "typeVersion": 1,
          "position": [
            900,
            500
          ],
          "notes": "Return 400 Bad Request for invalid packets"
        },
        {
          "parameters": {
            "respondWith": "json",
            "responseBody": "={{ JSON.stringify({ success: true, message: 'Packet accepted for processing', packet_id: $json.packet.packet_id, status: 'queued', callback_url: $json.packet.callback_url || 'none configured' }) }}",
            "options": {
              "responseCode": 202
            }
          },
          "id": "respond-accepted",
          "name": "Respond: Accepted (202)",
          "type": "n8n-nodes-base.respondToWebhook",
          "typeVersion": 1,
          "position": [
            900,
            200
          ],
          "notes": "Return 202 Accepted - packet will be processed asynchronously"
        },
        {
          "parameters": {
            "jsCode": "// Store packet in processing queue\nconst packet = $input.first().json.packet;\n\nreturn {\n  json: {\n    packet_id: packet.packet_id,\n    issue_id: packet.issue_id,\n    title: packet.title,\n    description: packet.description,\n    labels: packet.labels,\n    priority: packet.priority,\n    project_context: packet.project_context,\n    callback_url: packet.callback_url,\n    assigned_worker: packet.assigned_worker,\n    phase: packet.phase,\n    status: 'processing',\n    retry_count: packet.retry_count,\n    quality_config: packet.quality_config,\n    metadata: packet.metadata,\n    processing_started_at: new Date().toISOString()\n  }\n};"
          },
          "id": "prepare-for-processing",
          "name": "Prepare for Processing",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1120,
            200
          ],
          "notes": "Prepare packet for quality loop processing"
        },
        {
          "parameters": {
            "jsCode": "// Send progress callback if configured\nconst packet = $input.first().json;\n\nif (!packet.callback_url) {\n  return { json: { ...packet, progress_callback_skipped: true } };\n}\n\nif (!packet.quality_config.callback_on_progress) {\n  return { json: { ...packet, progress_callback_skipped: true } };\n}\n\nreturn {\n  json: {\n    ...packet,\n    progress_callback: {\n      should_send: true,\n      url: packet.callback_url,\n      payload: {\n        type: 'progress',\n        packet_id: packet.packet_id,\n        phase: packet.phase,\n        status: packet.status,\n        message: 'Processing started',\n        timestamp: new Date().toISOString()\n      }\n    }\n  }\n};"
          },
          "id": "check-progress-callback",
          "name": "Check Progress Callback",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1340,
            200
          ],
          "notes": "Determine if progress callback should be sent"
        },
        {
          "parameters": {
            "conditions": {
              "boolean": [
                {
                  "value1": "={{ $json.progress_callback?.should_send === true }}",
                  "value2": true
                }
              ]
            }
          },
          "id": "should-send-progress",
          "name": "Send Progress Callback?",
          "type": "n8n-nodes-base.if",
          "typeVersion": 2,
          "position": [
            1560,
            200
          ],
          "notes": "Route to callback sender if configured"
        },
        {
          "parameters": {
            "method": "POST",
            "url": "={{ $json.progress_callback.url }}",
            "sendHeaders": true,
            "headerParameters": {
              "parameters": [
                {
                  "name": "Content-Type",
                  "value": "application/json"
                },
                {
                  "name": "X-Claudia-Callback",
                  "value": "progress"
                },
                {
                  "name": "X-Packet-ID",
                  "value": "={{ $json.packet_id }}"
                }
              ]
            },
            "sendBody": true,
            "bodyParameters": {
              "parameters": [
                {
                  "name": "",
                  "value": "={{ $json.progress_callback.payload }}"
                }
              ]
            },
            "options": {
              "timeout": 10000,
              "allowUnauthorizedCerts": true
            }
          },
          "id": "send-progress-callback",
          "name": "Send Progress Callback",
          "type": "n8n-nodes-base.httpRequest",
          "typeVersion": 4.2,
          "position": [
            1780,
            100
          ],
          "notes": "Send progress notification to Claudia callback URL"
        },
        {
          "parameters": {},
          "id": "merge-progress-paths",
          "name": "Merge Progress Paths",
          "type": "n8n-nodes-base.merge",
          "typeVersion": 2.1,
          "position": [
            2000,
            200
          ],
          "notes": "Merge paths after optional progress callback"
        },
        {
          "parameters": {
            "jsCode": "// Build comprehensive prompt for implementation\nconst packet = $input.first().json;\n\nconst systemPrompt = `You are an expert software engineer working on a development task.\n\n## Project Context\n${packet.project_context || 'No specific project context provided.'}\n\n## Your Task\nImplement the following feature completely and correctly.\n\n## IMPORTANT REQUIREMENTS\n1. Write production-ready code with proper error handling\n2. Include comprehensive type hints and documentation  \n3. Write pytest tests that actually validate correctness\n4. Use modern Python best practices (3.11+)\n5. Include edge case handling\n6. No placeholder or TODO comments\n7. All dependencies must be clearly specified\n8. Code must be self-contained and runnable\n\n## DO NOT\n- Use deprecated APIs\n- Make unverified claims about \"production-ready\" code\n- Include logic errors or untested edge cases\n- Use in-memory stores without documenting limitations\n- Skip error handling\n\nIf you're unsure about an implementation detail, state your assumptions clearly.`;\n\nconst userPrompt = `# Task: ${packet.title}\n\n## Description\n${packet.description}\n\n## Requirements\n- Provide complete file structure\n- Include all necessary imports\n- Write comprehensive tests\n- Document assumptions and limitations\n- Specify exact dependency versions\n\n## Labels/Context\n${Array.isArray(packet.labels) ? packet.labels.join(', ') : 'None'}\n\n## Priority\n${packet.priority}\n\n## Deliver\n1. Complete implementation with file structure\n2. Test suite with coverage\n3. README with setup instructions\n4. requirements.txt or pyproject.toml\n5. Metadata section with assumptions and next steps`;\n\nreturn {\n  json: {\n    ...packet,\n    prompts: {\n      system: systemPrompt,\n      user: userPrompt\n    },\n    model_config: {\n      model: 'gpt-oss-20b',\n      temperature: 0.3,\n      max_tokens: 8000\n    }\n  }\n};"
          },
          "id": "build-implementation-prompt",
          "name": "Build Implementation Prompt",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            2220,
            200
          ],
          "notes": "Create detailed prompt with context and requirements"
        },
        {
          "parameters": {
            "method": "POST",
            "url": "={{ $env.LLM_API_ENDPOINT || 'http://192.168.245.200:1234' }}/v1/chat/completions",
            "authentication": "genericCredentialType",
            "genericAuthType": "httpHeaderAuth",
            "sendHeaders": true,
            "headerParameters": {
              "parameters": [
                {
                  "name": "Content-Type",
                  "value": "application/json"
                }
              ]
            },
            "sendBody": true,
            "specifyBody": "json",
            "jsonBody": "={{ { model: $json.model_config.model, messages: [{role: 'system', content: $json.prompts.system}, {role: 'user', content: $json.prompts.user}], temperature: $json.model_config.temperature, max_tokens: $json.model_config.max_tokens } }}",
            "options": {
              "timeout": 300000
            }
          },
          "id": "execute-implementation",
          "name": "Execute Implementation (LLM)",
          "type": "n8n-nodes-base.httpRequest",
          "typeVersion": 4.2,
          "position": [
            2440,
            200
          ],
          "notes": "Generate implementation using local LLM"
        },
        {
          "parameters": {
            "jsCode": "// Extract and format the implementation output\nconst item = $input.first();\nconst response = item.json.choices?.[0]?.message?.content || 'Error: No response from LLM';\nconst metadata = $node[\"Build Implementation Prompt\"].json;\n\nconst timestamp = new Date().toISOString();\nconst outputFilename = `${metadata.packet_id}-implementation-${Date.now()}.md`;\n\nreturn {\n  json: {\n    ...metadata,\n    implementation: {\n      raw_output: response,\n      timestamp: timestamp,\n      filename: outputFilename,\n      model: metadata.model_config.model,\n      phase: 'validation'\n    }\n  }\n};"
          },
          "id": "format-implementation",
          "name": "Format Implementation Output",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            2660,
            200
          ],
          "notes": "Extract response and prepare for validation"
        },
        {
          "parameters": {
            "jsCode": "// Build validation prompt for code review\nconst item = $input.first().json;\nconst implementation = item.implementation.raw_output;\n\nconst validationPrompt = `You are a senior software architect conducting a thorough code review.\n\nEvaluate this implementation against these criteria:\n\n## Code Quality Checklist\n1. **Correctness**: Logic errors, off-by-one errors, incorrect algorithms\n2. **Security**: Vulnerabilities, injection risks, insecure crypto\n3. **Testing**: Test coverage, edge cases, assertion quality\n4. **Dependencies**: Version specificity, deprecated APIs, compatibility\n5. **Error Handling**: Missing try/catch, unhandled edge cases\n6. **Documentation**: Accuracy of claims, missing assumptions\n7. **Best Practices**: Code smells, anti-patterns, maintainability\n8. **Completeness**: Missing files, incomplete implementations\n\n## Implementation to Review\n\n\\`\\`\\`markdown\n${implementation.substring(0, 15000)}\n\\`\\`\\`\n\n## Required Output Format\n\nProvide your evaluation as JSON:\n\n\\`\\`\\`json\n{\n  \"overall_quality_score\": <0-100>,\n  \"recommendation\": \"ACCEPT\" | \"ITERATE\" | \"REJECT\",\n  \"critical_issues\": [\n    {\"severity\": \"critical|major|minor\", \"category\": \"correctness|security|testing|etc\", \"description\": \"...\", \"location\": \"file:line or general\"}\n  ],\n  \"strengths\": [\"...\"],\n  \"weaknesses\": [\"...\"],\n  \"action_items\": [\n    {\"priority\": \"high|medium|low\", \"task\": \"...\", \"rationale\": \"...\"}\n  ],\n  \"direction_assessment\": \"Does this align with project goals? Explain.\",\n  \"suggested_next_steps\": [\"...\"]\n}\n\\`\\`\\`\n\nBe thorough and honest. Production systems depend on this evaluation.`;\n\nreturn {\n  json: {\n    ...item,\n    validation_prompt: validationPrompt\n  }\n};"
          },
          "id": "build-validation-prompt",
          "name": "Build Validation Prompt",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            2880,
            200
          ],
          "notes": "Prepare comprehensive code review prompt"
        },
        {
          "parameters": {
            "method": "POST",
            "url": "https://api.anthropic.com/v1/messages",
            "authentication": "genericCredentialType",
            "genericAuthType": "httpHeaderAuth",
            "sendHeaders": true,
            "headerParameters": {
              "parameters": [
                {
                  "name": "Content-Type",
                  "value": "application/json"
                },
                {
                  "name": "anthropic-version",
                  "value": "2023-06-01"
                }
              ]
            },
            "sendBody": true,
            "specifyBody": "json",
            "jsonBody": "={{ { model: 'claude-sonnet-4-20250514', max_tokens: 4096, messages: [{role: 'user', content: $json.validation_prompt}] } }}",
            "options": {
              "timeout": 180000
            }
          },
          "id": "execute-validation",
          "name": "Execute Validation (Claude)",
          "type": "n8n-nodes-base.httpRequest",
          "typeVersion": 4.2,
          "position": [
            3100,
            200
          ],
          "notes": "Use Claude for high-quality code review. Configure with Anthropic credential."
        },
        {
          "parameters": {
            "jsCode": "// Parse validation results\nconst item = $input.first();\nconst validationText = item.json.content?.[0]?.text || '';\n\n// Extract JSON from markdown code block\nconst jsonMatch = validationText.match(/```json\\n([\\s\\S]*?)\\n```/);\nlet validation;\n\nif (jsonMatch) {\n  try {\n    validation = JSON.parse(jsonMatch[1]);\n  } catch (e) {\n    validation = {\n      overall_quality_score: 50,\n      recommendation: 'ITERATE',\n      critical_issues: [{\n        severity: 'minor',\n        category: 'validation_parsing',\n        description: 'Could not parse validation JSON, will iterate',\n        location: 'validation'\n      }],\n      error: e.message\n    };\n  }\n} else {\n  // Fallback: try to parse entire response\n  try {\n    validation = JSON.parse(validationText);\n  } catch (e) {\n    // If parsing fails, create error structure\n    validation = {\n      overall_quality_score: 50,\n      recommendation: 'ITERATE',\n      critical_issues: [{\n        severity: 'minor',\n        category: 'validation_error',\n        description: 'Failed to parse validation response',\n        location: 'validation'\n      }],\n      error: e.message,\n      raw_response: validationText.substring(0, 500)\n    };\n  }\n}\n\nconst metadata = $node[\"Build Validation Prompt\"].json;\n\nreturn {\n  json: {\n    ...metadata,\n    validation: validation,\n    next_phase: validation.recommendation === 'ACCEPT' ? 'complete' : \n                validation.recommendation === 'ITERATE' ? 'iteration' : 'correction'\n  }\n};"
          },
          "id": "parse-validation",
          "name": "Parse Validation Results",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3320,
            200
          ],
          "notes": "Extract and parse JSON validation results"
        },
        {
          "parameters": {
            "rules": {
              "values": [
                {
                  "conditions": {
                    "string": [
                      {
                        "value1": "={{ $json.validation.recommendation }}",
                        "operation": "equals",
                        "value2": "ACCEPT"
                      }
                    ]
                  },
                  "output": 0
                },
                {
                  "conditions": {
                    "string": [
                      {
                        "value1": "={{ $json.validation.recommendation }}",
                        "operation": "equals",
                        "value2": "ITERATE"
                      }
                    ]
                  },
                  "output": 1
                },
                {
                  "conditions": {
                    "string": [
                      {
                        "value1": "={{ $json.validation.recommendation }}",
                        "operation": "equals",
                        "value2": "REJECT"
                      }
                    ]
                  },
                  "output": 2
                }
              ]
            }
          },
          "id": "decision-router",
          "name": "Route by Decision",
          "type": "n8n-nodes-base.switch",
          "typeVersion": 3,
          "position": [
            3540,
            200
          ],
          "notes": "Route based on validation recommendation: ACCEPT, ITERATE, or REJECT"
        },
        {
          "parameters": {
            "jsCode": "// ACCEPT: Prepare final result for callback\nconst item = $input.first().json;\n\nreturn {\n  json: {\n    packet_id: item.packet_id,\n    issue_id: item.issue_id,\n    title: item.title,\n    status: 'completed',\n    recommendation: 'ACCEPT',\n    quality_score: item.validation.overall_quality_score,\n    implementation: item.implementation,\n    validation: {\n      overall_quality_score: item.validation.overall_quality_score,\n      strengths: item.validation.strengths,\n      weaknesses: item.validation.weaknesses,\n      suggested_next_steps: item.validation.suggested_next_steps\n    },\n    callback_url: item.callback_url,\n    should_callback: item.quality_config.callback_on_complete && !!item.callback_url,\n    completed_at: new Date().toISOString()\n  }\n};"
          },
          "id": "prepare-accept-result",
          "name": "Prepare Accept Result",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3760,
            0
          ],
          "notes": "ACCEPT path: Prepare successful completion result"
        },
        {
          "parameters": {
            "jsCode": "// ITERATE: Check retry count and prepare for iteration\nconst item = $input.first().json;\nconst maxRetries = item.quality_config.max_retries || 3;\nconst currentRetry = item.retry_count || 0;\n\nif (currentRetry >= maxRetries || !item.quality_config.auto_iterate) {\n  // Max retries reached or auto-iterate disabled - return as partial success\n  return {\n    json: {\n      packet_id: item.packet_id,\n      issue_id: item.issue_id,\n      title: item.title,\n      status: 'completed_with_issues',\n      recommendation: 'ITERATE',\n      quality_score: item.validation.overall_quality_score,\n      implementation: item.implementation,\n      validation: item.validation,\n      callback_url: item.callback_url,\n      should_callback: item.quality_config.callback_on_complete && !!item.callback_url,\n      retry_count: currentRetry,\n      max_retries_reached: currentRetry >= maxRetries,\n      completed_at: new Date().toISOString()\n    }\n  };\n}\n\n// Prepare for iteration with improved prompt\nconst iterationNotes = item.validation.action_items\n  .filter(a => a.priority === 'high' || a.priority === 'medium')\n  .map(a => `- ${a.task}: ${a.rationale}`)\n  .join('\\n');\n\nreturn {\n  json: {\n    ...item,\n    status: 'iterating',\n    retry_count: currentRetry + 1,\n    iteration_notes: iterationNotes,\n    should_iterate: true\n  }\n};"
          },
          "id": "handle-iterate",
          "name": "Handle Iterate Decision",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3760,
            200
          ],
          "notes": "ITERATE path: Check retry limits and prepare iteration"
        },
        {
          "parameters": {
            "jsCode": "// REJECT: Prepare failure result\nconst item = $input.first().json;\n\nreturn {\n  json: {\n    packet_id: item.packet_id,\n    issue_id: item.issue_id,\n    title: item.title,\n    status: 'failed',\n    recommendation: 'REJECT',\n    quality_score: item.validation.overall_quality_score,\n    implementation: item.implementation,\n    validation: {\n      overall_quality_score: item.validation.overall_quality_score,\n      critical_issues: item.validation.critical_issues,\n      direction_assessment: item.validation.direction_assessment,\n      action_items: item.validation.action_items\n    },\n    callback_url: item.callback_url,\n    should_callback: item.quality_config.callback_on_complete && !!item.callback_url,\n    retry_count: item.retry_count,\n    failed_at: new Date().toISOString()\n  }\n};"
          },
          "id": "prepare-reject-result",
          "name": "Prepare Reject Result",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3760,
            400
          ],
          "notes": "REJECT path: Prepare failure result with details"
        },
        {
          "parameters": {
            "conditions": {
              "boolean": [
                {
                  "value1": "={{ $json.should_iterate === true }}",
                  "value2": true
                }
              ]
            }
          },
          "id": "check-should-iterate",
          "name": "Should Iterate?",
          "type": "n8n-nodes-base.if",
          "typeVersion": 2,
          "position": [
            3980,
            200
          ],
          "notes": "Check if we should loop back for iteration"
        },
        {
          "parameters": {},
          "id": "merge-final-results",
          "name": "Merge Final Results",
          "type": "n8n-nodes-base.merge",
          "typeVersion": 2.1,
          "position": [
            4200,
            300
          ],
          "notes": "Combine all paths that don't iterate"
        },
        {
          "parameters": {
            "conditions": {
              "boolean": [
                {
                  "value1": "={{ $json.should_callback === true }}",
                  "value2": true
                }
              ]
            }
          },
          "id": "check-should-callback",
          "name": "Should Send Callback?",
          "type": "n8n-nodes-base.if",
          "typeVersion": 2,
          "position": [
            4420,
            300
          ],
          "notes": "Determine if callback should be sent to Claudia"
        },
        {
          "parameters": {
            "method": "POST",
            "url": "={{ $json.callback_url }}",
            "sendHeaders": true,
            "headerParameters": {
              "parameters": [
                {
                  "name": "Content-Type",
                  "value": "application/json"
                },
                {
                  "name": "X-Claudia-Callback",
                  "value": "completion"
                },
                {
                  "name": "X-Packet-ID",
                  "value": "={{ $json.packet_id }}"
                },
                {
                  "name": "X-Status",
                  "value": "={{ $json.status }}"
                }
              ]
            },
            "sendBody": true,
            "specifyBody": "json",
            "jsonBody": "={{ { type: 'completion', packet_id: $json.packet_id, issue_id: $json.issue_id, title: $json.title, status: $json.status, recommendation: $json.recommendation, quality_score: $json.quality_score, implementation: { output: $json.implementation.raw_output, model: $json.implementation.model, timestamp: $json.implementation.timestamp }, validation: $json.validation, retry_count: $json.retry_count || 0, completed_at: $json.completed_at || $json.failed_at } }}",
            "options": {
              "timeout": 30000,
              "allowUnauthorizedCerts": true
            }
          },
          "id": "send-completion-callback",
          "name": "Send Completion Callback",
          "type": "n8n-nodes-base.httpRequest",
          "typeVersion": 4.2,
          "position": [
            4640,
            200
          ],
          "notes": "Send final results back to Claudia's callback URL"
        },
        {
          "parameters": {},
          "id": "merge-callback-paths",
          "name": "Merge Callback Paths",
          "type": "n8n-nodes-base.merge",
          "typeVersion": 2.1,
          "position": [
            4860,
            300
          ],
          "notes": "Merge after optional callback"
        },
        {
          "parameters": {
            "jsCode": "// Generate final execution summary\nconst item = $input.first().json;\n\nconst summary = {\n  execution_id: `EXEC-${Date.now()}`,\n  packet_id: item.packet_id || 'unknown',\n  issue_id: item.issue_id || null,\n  title: item.title || 'Unknown Task',\n  final_status: item.status || 'unknown',\n  recommendation: item.recommendation || 'N/A',\n  quality_score: item.quality_score || item.validation?.overall_quality_score || 0,\n  retries_used: item.retry_count || 0,\n  callback_sent: item.should_callback || false,\n  callback_url: item.callback_url || null,\n  completed_at: item.completed_at || item.failed_at || new Date().toISOString(),\n  processing_duration_estimate: 'See N8N execution logs for precise timing'\n};\n\nreturn { json: summary };"
          },
          "id": "generate-summary",
          "name": "Generate Summary",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            5080,
            300
          ],
          "notes": "Create execution summary for logging"
        },
        {
          "parameters": {
            "jsCode": "// Prepare iteration packet - loops back to implementation\nconst item = $input.first().json;\n\nconst improvedPrompt = `ITERATION #${item.retry_count}\n\nThe previous implementation attempt needs improvement.\n\n## Feedback from Code Review:\n${item.iteration_notes}\n\n## Quality Score: ${item.validation.overall_quality_score}/100\n\n## Critical Issues to Address:\n${(item.validation.critical_issues || []).map(i => `- [${i.severity}] ${i.category}: ${i.description}`).join('\\n')}\n\n## Original Requirements:\n${item.prompts.user}\n\n---\n\nPlease provide an IMPROVED implementation that:\n1. Addresses ALL the critical issues listed above\n2. Maintains all working aspects from the previous attempt\n3. Follows the specific action items from the review\n\nProvide the complete improved implementation.`;\n\nreturn {\n  json: {\n    ...item,\n    prompts: {\n      system: item.prompts.system,\n      user: improvedPrompt\n    },\n    phase: 'iteration',\n    model_config: {\n      model: item.model_config.model,\n      temperature: 0.2,  // Lower temperature for corrections\n      max_tokens: item.model_config.max_tokens\n    }\n  }\n};"
          },
          "id": "prepare-iteration",
          "name": "Prepare Iteration",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3980,
            100
          ],
          "notes": "Build improved prompt for iteration attempt"
        }
      ],
      "connections": {
        "Webhook: /claudia-execute": {
          "main": [
            [
              {
                "node": "Validate & Normalize Packet",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Validate & Normalize Packet": {
          "main": [
            [
              {
                "node": "Validation Passed?",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Validation Passed?": {
          "main": [
            [
              {
                "node": "Respond: Accepted (202)",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Respond: Validation Error",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Respond: Accepted (202)": {
          "main": [
            [
              {
                "node": "Prepare for Processing",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare for Processing": {
          "main": [
            [
              {
                "node": "Check Progress Callback",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Check Progress Callback": {
          "main": [
            [
              {
                "node": "Send Progress Callback?",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Send Progress Callback?": {
          "main": [
            [
              {
                "node": "Send Progress Callback",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Merge Progress Paths",
                "type": "main",
                "index": 1
              }
            ]
          ]
        },
        "Send Progress Callback": {
          "main": [
            [
              {
                "node": "Merge Progress Paths",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Merge Progress Paths": {
          "main": [
            [
              {
                "node": "Build Implementation Prompt",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Build Implementation Prompt": {
          "main": [
            [
              {
                "node": "Execute Implementation (LLM)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Execute Implementation (LLM)": {
          "main": [
            [
              {
                "node": "Format Implementation Output",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Format Implementation Output": {
          "main": [
            [
              {
                "node": "Build Validation Prompt",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Build Validation Prompt": {
          "main": [
            [
              {
                "node": "Execute Validation (Claude)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Execute Validation (Claude)": {
          "main": [
            [
              {
                "node": "Parse Validation Results",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Parse Validation Results": {
          "main": [
            [
              {
                "node": "Route by Decision",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Route by Decision": {
          "main": [
            [
              {
                "node": "Prepare Accept Result",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Handle Iterate Decision",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Prepare Reject Result",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Accept Result": {
          "main": [
            [
              {
                "node": "Merge Final Results",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Handle Iterate Decision": {
          "main": [
            [
              {
                "node": "Check Should Iterate?",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Check Should Iterate?": {
          "main": [
            [
              {
                "node": "Prepare Iteration",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Merge Final Results",
                "type": "main",
                "index": 1
              }
            ]
          ]
        },
        "Prepare Reject Result": {
          "main": [
            [
              {
                "node": "Merge Final Results",
                "type": "main",
                "index": 2
              }
            ]
          ]
        },
        "Merge Final Results": {
          "main": [
            [
              {
                "node": "Should Send Callback?",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Should Send Callback?": {
          "main": [
            [
              {
                "node": "Send Completion Callback",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Merge Callback Paths",
                "type": "main",
                "index": 1
              }
            ]
          ]
        },
        "Send Completion Callback": {
          "main": [
            [
              {
                "node": "Merge Callback Paths",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Merge Callback Paths": {
          "main": [
            [
              {
                "node": "Generate Summary",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Iteration": {
          "main": [
            [
              {
                "node": "Execute Implementation (LLM)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        }
      },
      "authors": "Bill Griffith",
      "name": null,
      "description": null
    },
    "tags": []
  },
  {
    "updatedAt": "2026-01-08T04:31:22.143Z",
    "createdAt": "2026-01-08T04:31:22.143Z",
    "id": "HoHkZgq9xzIC9Ing",
    "name": "Claudia Webhook Trigger - Quality Loop Pipeline",
    "active": false,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "claudia-execute",
          "options": {
            "rawBody": false,
            "responseCode": 202,
            "responseData": "firstEntryJson"
          },
          "authentication": "headerAuth",
          "headerAuth": {
            "name": "X-Claudia-Token"
          }
        },
        "id": "webhook-claudia-execute",
        "name": "Webhook: /claudia-execute",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          240,
          300
        ],
        "webhookId": "claudia-execute",
        "notes": "Main entry point for Claudia to submit work packets. Endpoint: POST /webhook/claudia-execute"
      },
      {
        "parameters": {
          "jsCode": "// Validate and normalize incoming packet from Claudia\nconst input = $input.first().json;\nconst headers = $input.first().json.headers || {};\nconst body = input.body || input;\n\n// Generate packet ID if not provided\nconst packetId = body.packet_id || body.packetID || `PKT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n// Validate required fields\nconst errors = [];\nif (!body.title && !body.description && !body.issue_id) {\n  errors.push('At least one of title, description, or issue_id is required');\n}\n\nif (errors.length > 0) {\n  return {\n    json: {\n      success: false,\n      error: 'Validation failed',\n      errors: errors,\n      packet_id: packetId,\n      received_at: new Date().toISOString()\n    }\n  };\n}\n\n// Normalize the packet structure\nconst normalizedPacket = {\n  packet_id: packetId,\n  issue_id: body.issue_id || body.issueID || null,\n  title: body.title || 'Untitled Task',\n  description: body.description || body.summary || '',\n  labels: body.labels || [],\n  priority: body.priority || 'medium',\n  project_context: body.project_context || body.projectContext || '',\n  callback_url: body.callback_url || body.callbackUrl || null,\n  callback_method: body.callback_method || 'POST',\n  assigned_worker: body.assigned_worker || body.assignedWorker || 'worker_bee_gptoss',\n  project_id: body.project_id || body.projectID || null,\n  metadata: {\n    source: 'claudia_webhook',\n    received_at: new Date().toISOString(),\n    request_headers: {\n      user_agent: headers['user-agent'] || 'unknown',\n      x_request_id: headers['x-request-id'] || packetId\n    }\n  },\n  \n  // Processing state\n  phase: 'initial_implementation',\n  status: 'queued',\n  retry_count: body.retry_count || 0,\n  previous_attempts: body.previous_attempts || [],\n  \n  // Quality loop configuration\n  quality_config: {\n    max_retries: body.max_retries || 3,\n    validation_required: body.validation_required !== false,\n    auto_iterate: body.auto_iterate !== false,\n    callback_on_progress: body.callback_on_progress || false,\n    callback_on_complete: body.callback_on_complete !== false\n  }\n};\n\nreturn {\n  json: {\n    success: true,\n    message: 'Packet accepted for processing',\n    packet: normalizedPacket\n  }\n};"
        },
        "id": "validate-packet",
        "name": "Validate & Normalize Packet",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          460,
          300
        ],
        "notes": "Validates incoming packet and normalizes structure for processing"
      },
      {
        "parameters": {
          "conditions": {
            "boolean": [
              {
                "value1": "={{ $json.success }}",
                "value2": true
              }
            ]
          }
        },
        "id": "check-validation",
        "name": "Validation Passed?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          680,
          300
        ],
        "notes": "Route valid packets to processing, invalid to error response"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ success: false, error: $json.error, errors: $json.errors, packet_id: $json.packet_id }) }}",
          "options": {
            "responseCode": 400
          }
        },
        "id": "respond-validation-error",
        "name": "Respond: Validation Error",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          900,
          500
        ],
        "notes": "Return 400 Bad Request for invalid packets"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ success: true, message: 'Packet accepted for processing', packet_id: $json.packet.packet_id, status: 'queued', callback_url: $json.packet.callback_url || 'none configured' }) }}",
          "options": {
            "responseCode": 202
          }
        },
        "id": "respond-accepted",
        "name": "Respond: Accepted (202)",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          900,
          200
        ],
        "notes": "Return 202 Accepted - packet will be processed asynchronously"
      },
      {
        "parameters": {
          "jsCode": "// Store packet in processing queue\nconst packet = $input.first().json.packet;\n\nreturn {\n  json: {\n    packet_id: packet.packet_id,\n    issue_id: packet.issue_id,\n    title: packet.title,\n    description: packet.description,\n    labels: packet.labels,\n    priority: packet.priority,\n    project_context: packet.project_context,\n    callback_url: packet.callback_url,\n    assigned_worker: packet.assigned_worker,\n    phase: packet.phase,\n    status: 'processing',\n    retry_count: packet.retry_count,\n    quality_config: packet.quality_config,\n    metadata: packet.metadata,\n    processing_started_at: new Date().toISOString()\n  }\n};"
        },
        "id": "prepare-for-processing",
        "name": "Prepare for Processing",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1120,
          200
        ],
        "notes": "Prepare packet for quality loop processing"
      },
      {
        "parameters": {
          "jsCode": "// Send progress callback if configured\nconst packet = $input.first().json;\n\nif (!packet.callback_url) {\n  return { json: { ...packet, progress_callback_skipped: true } };\n}\n\nif (!packet.quality_config.callback_on_progress) {\n  return { json: { ...packet, progress_callback_skipped: true } };\n}\n\nreturn {\n  json: {\n    ...packet,\n    progress_callback: {\n      should_send: true,\n      url: packet.callback_url,\n      payload: {\n        type: 'progress',\n        packet_id: packet.packet_id,\n        phase: packet.phase,\n        status: packet.status,\n        message: 'Processing started',\n        timestamp: new Date().toISOString()\n      }\n    }\n  }\n};"
        },
        "id": "check-progress-callback",
        "name": "Check Progress Callback",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1340,
          200
        ],
        "notes": "Determine if progress callback should be sent"
      },
      {
        "parameters": {
          "conditions": {
            "boolean": [
              {
                "value1": "={{ $json.progress_callback?.should_send === true }}",
                "value2": true
              }
            ]
          }
        },
        "id": "should-send-progress",
        "name": "Send Progress Callback?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          1560,
          200
        ],
        "notes": "Route to callback sender if configured"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $json.progress_callback.url }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "X-Claudia-Callback",
                "value": "progress"
              },
              {
                "name": "X-Packet-ID",
                "value": "={{ $json.packet_id }}"
              }
            ]
          },
          "sendBody": true,
          "bodyParameters": {
            "parameters": [
              {
                "name": "",
                "value": "={{ $json.progress_callback.payload }}"
              }
            ]
          },
          "options": {
            "timeout": 10000,
            "allowUnauthorizedCerts": true
          }
        },
        "id": "send-progress-callback",
        "name": "Send Progress Callback",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1780,
          100
        ],
        "notes": "Send progress notification to Claudia callback URL"
      },
      {
        "parameters": {},
        "id": "merge-progress-paths",
        "name": "Merge Progress Paths",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 2.1,
        "position": [
          2000,
          200
        ],
        "notes": "Merge paths after optional progress callback"
      },
      {
        "parameters": {
          "jsCode": "// Build comprehensive prompt for implementation\nconst packet = $input.first().json;\n\nconst systemPrompt = `You are an expert software engineer working on a development task.\n\n## Project Context\n${packet.project_context || 'No specific project context provided.'}\n\n## Your Task\nImplement the following feature completely and correctly.\n\n## IMPORTANT REQUIREMENTS\n1. Write production-ready code with proper error handling\n2. Include comprehensive type hints and documentation  \n3. Write pytest tests that actually validate correctness\n4. Use modern Python best practices (3.11+)\n5. Include edge case handling\n6. No placeholder or TODO comments\n7. All dependencies must be clearly specified\n8. Code must be self-contained and runnable\n\n## DO NOT\n- Use deprecated APIs\n- Make unverified claims about \"production-ready\" code\n- Include logic errors or untested edge cases\n- Use in-memory stores without documenting limitations\n- Skip error handling\n\nIf you're unsure about an implementation detail, state your assumptions clearly.`;\n\nconst userPrompt = `# Task: ${packet.title}\n\n## Description\n${packet.description}\n\n## Requirements\n- Provide complete file structure\n- Include all necessary imports\n- Write comprehensive tests\n- Document assumptions and limitations\n- Specify exact dependency versions\n\n## Labels/Context\n${Array.isArray(packet.labels) ? packet.labels.join(', ') : 'None'}\n\n## Priority\n${packet.priority}\n\n## Deliver\n1. Complete implementation with file structure\n2. Test suite with coverage\n3. README with setup instructions\n4. requirements.txt or pyproject.toml\n5. Metadata section with assumptions and next steps`;\n\nreturn {\n  json: {\n    ...packet,\n    prompts: {\n      system: systemPrompt,\n      user: userPrompt\n    },\n    model_config: {\n      model: 'gpt-oss-20b',\n      temperature: 0.3,\n      max_tokens: 8000\n    }\n  }\n};"
        },
        "id": "build-implementation-prompt",
        "name": "Build Implementation Prompt",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2220,
          200
        ],
        "notes": "Create detailed prompt with context and requirements"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $env.LLM_API_ENDPOINT || 'http://192.168.245.200:1234' }}/v1/chat/completions",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { model: $json.model_config.model, messages: [{role: 'system', content: $json.prompts.system}, {role: 'user', content: $json.prompts.user}], temperature: $json.model_config.temperature, max_tokens: $json.model_config.max_tokens } }}",
          "options": {
            "timeout": 300000
          }
        },
        "id": "execute-implementation",
        "name": "Execute Implementation (LLM)",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          2440,
          200
        ],
        "notes": "Generate implementation using local LLM"
      },
      {
        "parameters": {
          "jsCode": "// Extract and format the implementation output\nconst item = $input.first();\nconst response = item.json.choices?.[0]?.message?.content || 'Error: No response from LLM';\nconst metadata = $node[\"Build Implementation Prompt\"].json;\n\nconst timestamp = new Date().toISOString();\nconst outputFilename = `${metadata.packet_id}-implementation-${Date.now()}.md`;\n\nreturn {\n  json: {\n    ...metadata,\n    implementation: {\n      raw_output: response,\n      timestamp: timestamp,\n      filename: outputFilename,\n      model: metadata.model_config.model,\n      phase: 'validation'\n    }\n  }\n};"
        },
        "id": "format-implementation",
        "name": "Format Implementation Output",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2660,
          200
        ],
        "notes": "Extract response and prepare for validation"
      },
      {
        "parameters": {
          "jsCode": "// Build validation prompt for code review\nconst item = $input.first().json;\nconst implementation = item.implementation.raw_output;\n\nconst validationPrompt = `You are a senior software architect conducting a thorough code review.\n\nEvaluate this implementation against these criteria:\n\n## Code Quality Checklist\n1. **Correctness**: Logic errors, off-by-one errors, incorrect algorithms\n2. **Security**: Vulnerabilities, injection risks, insecure crypto\n3. **Testing**: Test coverage, edge cases, assertion quality\n4. **Dependencies**: Version specificity, deprecated APIs, compatibility\n5. **Error Handling**: Missing try/catch, unhandled edge cases\n6. **Documentation**: Accuracy of claims, missing assumptions\n7. **Best Practices**: Code smells, anti-patterns, maintainability\n8. **Completeness**: Missing files, incomplete implementations\n\n## Implementation to Review\n\n\\`\\`\\`markdown\n${implementation.substring(0, 15000)}\n\\`\\`\\`\n\n## Required Output Format\n\nProvide your evaluation as JSON:\n\n\\`\\`\\`json\n{\n  \"overall_quality_score\": <0-100>,\n  \"recommendation\": \"ACCEPT\" | \"ITERATE\" | \"REJECT\",\n  \"critical_issues\": [\n    {\"severity\": \"critical|major|minor\", \"category\": \"correctness|security|testing|etc\", \"description\": \"...\", \"location\": \"file:line or general\"}\n  ],\n  \"strengths\": [\"...\"],\n  \"weaknesses\": [\"...\"],\n  \"action_items\": [\n    {\"priority\": \"high|medium|low\", \"task\": \"...\", \"rationale\": \"...\"}\n  ],\n  \"direction_assessment\": \"Does this align with project goals? Explain.\",\n  \"suggested_next_steps\": [\"...\"]\n}\n\\`\\`\\`\n\nBe thorough and honest. Production systems depend on this evaluation.`;\n\nreturn {\n  json: {\n    ...item,\n    validation_prompt: validationPrompt\n  }\n};"
        },
        "id": "build-validation-prompt",
        "name": "Build Validation Prompt",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2880,
          200
        ],
        "notes": "Prepare comprehensive code review prompt"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.anthropic.com/v1/messages",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "anthropic-version",
                "value": "2023-06-01"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { model: 'claude-sonnet-4-20250514', max_tokens: 4096, messages: [{role: 'user', content: $json.validation_prompt}] } }}",
          "options": {
            "timeout": 180000
          }
        },
        "id": "execute-validation",
        "name": "Execute Validation (Claude)",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          3100,
          200
        ],
        "notes": "Use Claude for high-quality code review. Configure with Anthropic credential."
      },
      {
        "parameters": {
          "jsCode": "// Parse validation results\nconst item = $input.first();\nconst validationText = item.json.content?.[0]?.text || '';\n\n// Extract JSON from markdown code block\nconst jsonMatch = validationText.match(/```json\\n([\\s\\S]*?)\\n```/);\nlet validation;\n\nif (jsonMatch) {\n  try {\n    validation = JSON.parse(jsonMatch[1]);\n  } catch (e) {\n    validation = {\n      overall_quality_score: 50,\n      recommendation: 'ITERATE',\n      critical_issues: [{\n        severity: 'minor',\n        category: 'validation_parsing',\n        description: 'Could not parse validation JSON, will iterate',\n        location: 'validation'\n      }],\n      error: e.message\n    };\n  }\n} else {\n  // Fallback: try to parse entire response\n  try {\n    validation = JSON.parse(validationText);\n  } catch (e) {\n    // If parsing fails, create error structure\n    validation = {\n      overall_quality_score: 50,\n      recommendation: 'ITERATE',\n      critical_issues: [{\n        severity: 'minor',\n        category: 'validation_error',\n        description: 'Failed to parse validation response',\n        location: 'validation'\n      }],\n      error: e.message,\n      raw_response: validationText.substring(0, 500)\n    };\n  }\n}\n\nconst metadata = $node[\"Build Validation Prompt\"].json;\n\nreturn {\n  json: {\n    ...metadata,\n    validation: validation,\n    next_phase: validation.recommendation === 'ACCEPT' ? 'complete' : \n                validation.recommendation === 'ITERATE' ? 'iteration' : 'correction'\n  }\n};"
        },
        "id": "parse-validation",
        "name": "Parse Validation Results",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3320,
          200
        ],
        "notes": "Extract and parse JSON validation results"
      },
      {
        "parameters": {
          "rules": {
            "values": [
              {
                "conditions": {
                  "string": [
                    {
                      "value1": "={{ $json.validation.recommendation }}",
                      "operation": "equals",
                      "value2": "ACCEPT"
                    }
                  ]
                },
                "output": 0
              },
              {
                "conditions": {
                  "string": [
                    {
                      "value1": "={{ $json.validation.recommendation }}",
                      "operation": "equals",
                      "value2": "ITERATE"
                    }
                  ]
                },
                "output": 1
              },
              {
                "conditions": {
                  "string": [
                    {
                      "value1": "={{ $json.validation.recommendation }}",
                      "operation": "equals",
                      "value2": "REJECT"
                    }
                  ]
                },
                "output": 2
              }
            ]
          }
        },
        "id": "decision-router",
        "name": "Route by Decision",
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3,
        "position": [
          3540,
          200
        ],
        "notes": "Route based on validation recommendation: ACCEPT, ITERATE, or REJECT"
      },
      {
        "parameters": {
          "jsCode": "// ACCEPT: Prepare final result for callback\nconst item = $input.first().json;\n\nreturn {\n  json: {\n    packet_id: item.packet_id,\n    issue_id: item.issue_id,\n    title: item.title,\n    status: 'completed',\n    recommendation: 'ACCEPT',\n    quality_score: item.validation.overall_quality_score,\n    implementation: item.implementation,\n    validation: {\n      overall_quality_score: item.validation.overall_quality_score,\n      strengths: item.validation.strengths,\n      weaknesses: item.validation.weaknesses,\n      suggested_next_steps: item.validation.suggested_next_steps\n    },\n    callback_url: item.callback_url,\n    should_callback: item.quality_config.callback_on_complete && !!item.callback_url,\n    completed_at: new Date().toISOString()\n  }\n};"
        },
        "id": "prepare-accept-result",
        "name": "Prepare Accept Result",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3760,
          0
        ],
        "notes": "ACCEPT path: Prepare successful completion result"
      },
      {
        "parameters": {
          "jsCode": "// ITERATE: Check retry count and prepare for iteration\nconst item = $input.first().json;\nconst maxRetries = item.quality_config.max_retries || 3;\nconst currentRetry = item.retry_count || 0;\n\nif (currentRetry >= maxRetries || !item.quality_config.auto_iterate) {\n  // Max retries reached or auto-iterate disabled - return as partial success\n  return {\n    json: {\n      packet_id: item.packet_id,\n      issue_id: item.issue_id,\n      title: item.title,\n      status: 'completed_with_issues',\n      recommendation: 'ITERATE',\n      quality_score: item.validation.overall_quality_score,\n      implementation: item.implementation,\n      validation: item.validation,\n      callback_url: item.callback_url,\n      should_callback: item.quality_config.callback_on_complete && !!item.callback_url,\n      retry_count: currentRetry,\n      max_retries_reached: currentRetry >= maxRetries,\n      completed_at: new Date().toISOString()\n    }\n  };\n}\n\n// Prepare for iteration with improved prompt\nconst iterationNotes = item.validation.action_items\n  .filter(a => a.priority === 'high' || a.priority === 'medium')\n  .map(a => `- ${a.task}: ${a.rationale}`)\n  .join('\\n');\n\nreturn {\n  json: {\n    ...item,\n    status: 'iterating',\n    retry_count: currentRetry + 1,\n    iteration_notes: iterationNotes,\n    should_iterate: true\n  }\n};"
        },
        "id": "handle-iterate",
        "name": "Handle Iterate Decision",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3760,
          200
        ],
        "notes": "ITERATE path: Check retry limits and prepare iteration"
      },
      {
        "parameters": {
          "jsCode": "// REJECT: Prepare failure result\nconst item = $input.first().json;\n\nreturn {\n  json: {\n    packet_id: item.packet_id,\n    issue_id: item.issue_id,\n    title: item.title,\n    status: 'failed',\n    recommendation: 'REJECT',\n    quality_score: item.validation.overall_quality_score,\n    implementation: item.implementation,\n    validation: {\n      overall_quality_score: item.validation.overall_quality_score,\n      critical_issues: item.validation.critical_issues,\n      direction_assessment: item.validation.direction_assessment,\n      action_items: item.validation.action_items\n    },\n    callback_url: item.callback_url,\n    should_callback: item.quality_config.callback_on_complete && !!item.callback_url,\n    retry_count: item.retry_count,\n    failed_at: new Date().toISOString()\n  }\n};"
        },
        "id": "prepare-reject-result",
        "name": "Prepare Reject Result",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3760,
          400
        ],
        "notes": "REJECT path: Prepare failure result with details"
      },
      {
        "parameters": {
          "conditions": {
            "boolean": [
              {
                "value1": "={{ $json.should_iterate === true }}",
                "value2": true
              }
            ]
          }
        },
        "id": "check-should-iterate",
        "name": "Should Iterate?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          3980,
          200
        ],
        "notes": "Check if we should loop back for iteration"
      },
      {
        "parameters": {},
        "id": "merge-final-results",
        "name": "Merge Final Results",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 2.1,
        "position": [
          4200,
          300
        ],
        "notes": "Combine all paths that don't iterate"
      },
      {
        "parameters": {
          "conditions": {
            "boolean": [
              {
                "value1": "={{ $json.should_callback === true }}",
                "value2": true
              }
            ]
          }
        },
        "id": "check-should-callback",
        "name": "Should Send Callback?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          4420,
          300
        ],
        "notes": "Determine if callback should be sent to Claudia"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $json.callback_url }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "X-Claudia-Callback",
                "value": "completion"
              },
              {
                "name": "X-Packet-ID",
                "value": "={{ $json.packet_id }}"
              },
              {
                "name": "X-Status",
                "value": "={{ $json.status }}"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { type: 'completion', packet_id: $json.packet_id, issue_id: $json.issue_id, title: $json.title, status: $json.status, recommendation: $json.recommendation, quality_score: $json.quality_score, implementation: { output: $json.implementation.raw_output, model: $json.implementation.model, timestamp: $json.implementation.timestamp }, validation: $json.validation, retry_count: $json.retry_count || 0, completed_at: $json.completed_at || $json.failed_at } }}",
          "options": {
            "timeout": 30000,
            "allowUnauthorizedCerts": true
          }
        },
        "id": "send-completion-callback",
        "name": "Send Completion Callback",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          4640,
          200
        ],
        "notes": "Send final results back to Claudia's callback URL"
      },
      {
        "parameters": {},
        "id": "merge-callback-paths",
        "name": "Merge Callback Paths",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 2.1,
        "position": [
          4860,
          300
        ],
        "notes": "Merge after optional callback"
      },
      {
        "parameters": {
          "jsCode": "// Generate final execution summary\nconst item = $input.first().json;\n\nconst summary = {\n  execution_id: `EXEC-${Date.now()}`,\n  packet_id: item.packet_id || 'unknown',\n  issue_id: item.issue_id || null,\n  title: item.title || 'Unknown Task',\n  final_status: item.status || 'unknown',\n  recommendation: item.recommendation || 'N/A',\n  quality_score: item.quality_score || item.validation?.overall_quality_score || 0,\n  retries_used: item.retry_count || 0,\n  callback_sent: item.should_callback || false,\n  callback_url: item.callback_url || null,\n  completed_at: item.completed_at || item.failed_at || new Date().toISOString(),\n  processing_duration_estimate: 'See N8N execution logs for precise timing'\n};\n\nreturn { json: summary };"
        },
        "id": "generate-summary",
        "name": "Generate Summary",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5080,
          300
        ],
        "notes": "Create execution summary for logging"
      },
      {
        "parameters": {
          "jsCode": "// Prepare iteration packet - loops back to implementation\nconst item = $input.first().json;\n\nconst improvedPrompt = `ITERATION #${item.retry_count}\n\nThe previous implementation attempt needs improvement.\n\n## Feedback from Code Review:\n${item.iteration_notes}\n\n## Quality Score: ${item.validation.overall_quality_score}/100\n\n## Critical Issues to Address:\n${(item.validation.critical_issues || []).map(i => `- [${i.severity}] ${i.category}: ${i.description}`).join('\\n')}\n\n## Original Requirements:\n${item.prompts.user}\n\n---\n\nPlease provide an IMPROVED implementation that:\n1. Addresses ALL the critical issues listed above\n2. Maintains all working aspects from the previous attempt\n3. Follows the specific action items from the review\n\nProvide the complete improved implementation.`;\n\nreturn {\n  json: {\n    ...item,\n    prompts: {\n      system: item.prompts.system,\n      user: improvedPrompt\n    },\n    phase: 'iteration',\n    model_config: {\n      model: item.model_config.model,\n      temperature: 0.2,  // Lower temperature for corrections\n      max_tokens: item.model_config.max_tokens\n    }\n  }\n};"
        },
        "id": "prepare-iteration",
        "name": "Prepare Iteration",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3980,
          100
        ],
        "notes": "Build improved prompt for iteration attempt"
      }
    ],
    "connections": {
      "Webhook: /claudia-execute": {
        "main": [
          [
            {
              "node": "Validate & Normalize Packet",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate & Normalize Packet": {
        "main": [
          [
            {
              "node": "Validation Passed?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validation Passed?": {
        "main": [
          [
            {
              "node": "Respond: Accepted (202)",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Respond: Validation Error",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Respond: Accepted (202)": {
        "main": [
          [
            {
              "node": "Prepare for Processing",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare for Processing": {
        "main": [
          [
            {
              "node": "Check Progress Callback",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Progress Callback": {
        "main": [
          [
            {
              "node": "Send Progress Callback?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Progress Callback?": {
        "main": [
          [
            {
              "node": "Send Progress Callback",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Merge Progress Paths",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Send Progress Callback": {
        "main": [
          [
            {
              "node": "Merge Progress Paths",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Progress Paths": {
        "main": [
          [
            {
              "node": "Build Implementation Prompt",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Implementation Prompt": {
        "main": [
          [
            {
              "node": "Execute Implementation (LLM)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Implementation (LLM)": {
        "main": [
          [
            {
              "node": "Format Implementation Output",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format Implementation Output": {
        "main": [
          [
            {
              "node": "Build Validation Prompt",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Validation Prompt": {
        "main": [
          [
            {
              "node": "Execute Validation (Claude)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Validation (Claude)": {
        "main": [
          [
            {
              "node": "Parse Validation Results",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Validation Results": {
        "main": [
          [
            {
              "node": "Route by Decision",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Route by Decision": {
        "main": [
          [
            {
              "node": "Prepare Accept Result",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Handle Iterate Decision",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Prepare Reject Result",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Accept Result": {
        "main": [
          [
            {
              "node": "Merge Final Results",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Handle Iterate Decision": {
        "main": [
          [
            {
              "node": "Check Should Iterate?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Should Iterate?": {
        "main": [
          [
            {
              "node": "Prepare Iteration",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Merge Final Results",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Prepare Reject Result": {
        "main": [
          [
            {
              "node": "Merge Final Results",
              "type": "main",
              "index": 2
            }
          ]
        ]
      },
      "Merge Final Results": {
        "main": [
          [
            {
              "node": "Should Send Callback?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Should Send Callback?": {
        "main": [
          [
            {
              "node": "Send Completion Callback",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Merge Callback Paths",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Send Completion Callback": {
        "main": [
          [
            {
              "node": "Merge Callback Paths",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Callback Paths": {
        "main": [
          [
            {
              "node": "Generate Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Iteration": {
        "main": [
          [
            {
              "node": "Execute Implementation (LLM)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1",
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "54635243-2103-4666-9d2f-327766610f41",
    "activeVersionId": null,
    "triggerCount": 1,
    "shared": [
      {
        "updatedAt": "2026-01-08T04:31:22.151Z",
        "createdAt": "2026-01-08T04:31:22.151Z",
        "role": "workflow:owner",
        "workflowId": "HoHkZgq9xzIC9Ing",
        "projectId": "CDNyPtsGxHdhfdhy"
      }
    ],
    "activeVersion": null,
    "tags": []
  },
  {
    "updatedAt": "2026-01-08T04:35:10.615Z",
    "createdAt": "2026-01-08T04:35:10.615Z",
    "id": "bUUs2y75OZ0C3rJn",
    "name": "Claudia Simple Webhook - Working",
    "active": true,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "claudia-simple",
          "options": {}
        },
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          240,
          300
        ],
        "id": "6fd5e469-87f2-498f-bfbf-3ba4f8ceadb1"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ success: true, message: 'Received', data: $json }) }}",
          "options": {}
        },
        "name": "Respond to Webhook",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          460,
          300
        ],
        "id": "fa0d4df4-ede9-44c1-bf83-0cb494026a23"
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1",
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "e19345c4-fcfd-4703-a377-e7218d1ae4c1",
    "activeVersionId": "e19345c4-fcfd-4703-a377-e7218d1ae4c1",
    "triggerCount": 1,
    "shared": [
      {
        "updatedAt": "2026-01-08T04:35:10.617Z",
        "createdAt": "2026-01-08T04:35:10.617Z",
        "role": "workflow:owner",
        "workflowId": "bUUs2y75OZ0C3rJn",
        "projectId": "CDNyPtsGxHdhfdhy"
      }
    ],
    "activeVersion": {
      "updatedAt": "2026-01-08T04:35:10.626Z",
      "createdAt": "2026-01-08T04:35:10.626Z",
      "versionId": "e19345c4-fcfd-4703-a377-e7218d1ae4c1",
      "workflowId": "bUUs2y75OZ0C3rJn",
      "nodes": [
        {
          "parameters": {
            "httpMethod": "POST",
            "path": "claudia-simple",
            "options": {}
          },
          "name": "Webhook",
          "type": "n8n-nodes-base.webhook",
          "typeVersion": 2,
          "position": [
            240,
            300
          ],
          "id": "6fd5e469-87f2-498f-bfbf-3ba4f8ceadb1"
        },
        {
          "parameters": {
            "respondWith": "json",
            "responseBody": "={{ JSON.stringify({ success: true, message: 'Received', data: $json }) }}",
            "options": {}
          },
          "name": "Respond to Webhook",
          "type": "n8n-nodes-base.respondToWebhook",
          "typeVersion": 1,
          "position": [
            460,
            300
          ],
          "id": "fa0d4df4-ede9-44c1-bf83-0cb494026a23"
        }
      ],
      "connections": {
        "Webhook": {
          "main": [
            [
              {
                "node": "Respond to Webhook",
                "type": "main",
                "index": 0
              }
            ]
          ]
        }
      },
      "authors": "Bill Griffith",
      "name": null,
      "description": null
    },
    "tags": []
  },
  {
    "updatedAt": "2026-01-08T04:34:54.737Z",
    "createdAt": "2026-01-08T04:34:54.737Z",
    "id": "k8WuYzk6FPt55nk1",
    "name": "Claudia Simple Webhook - Working",
    "active": false,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "claudia-simple",
          "options": {}
        },
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          240,
          300
        ],
        "id": "93b8f537-c4c5-4959-871e-573a4d354a00"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ success: true, message: \"Received\", data: $json }) }}",
          "options": {}
        },
        "name": "Respond to Webhook",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          460,
          300
        ],
        "id": "66e9247e-bd6b-4d3e-9f86-c4bb10020fe1"
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1",
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "0e5dc720-39d6-4d43-92d9-187de5b18353",
    "activeVersionId": null,
    "triggerCount": 0,
    "shared": [
      {
        "updatedAt": "2026-01-08T04:34:54.757Z",
        "createdAt": "2026-01-08T04:34:54.757Z",
        "role": "workflow:owner",
        "workflowId": "k8WuYzk6FPt55nk1",
        "projectId": "CDNyPtsGxHdhfdhy"
      }
    ],
    "activeVersion": null,
    "tags": []
  },
  {
    "updatedAt": "2026-01-08T04:35:03.092Z",
    "createdAt": "2026-01-08T04:35:03.092Z",
    "id": "yZQN8BoBDRDVjO7L",
    "name": "Claudia Simple Webhook - Working",
    "active": false,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "claudia-simple",
          "options": {}
        },
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          240,
          300
        ],
        "id": "f1e9db91-e9f6-4d84-a1a8-7a5e134f32aa"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ success: true, message: \"Received\", data: $json }) }}",
          "options": {}
        },
        "name": "Respond to Webhook",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          460,
          300
        ],
        "id": "776b54f5-ea60-4a95-a81c-6d55026952a1"
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1",
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "04b81b69-e088-4d78-860f-a7667d118155",
    "activeVersionId": null,
    "triggerCount": 0,
    "shared": [
      {
        "updatedAt": "2026-01-08T04:35:03.098Z",
        "createdAt": "2026-01-08T04:35:03.098Z",
        "role": "workflow:owner",
        "workflowId": "yZQN8BoBDRDVjO7L",
        "projectId": "CDNyPtsGxHdhfdhy"
      }
    ],
    "activeVersion": null,
    "tags": []
  }
]
