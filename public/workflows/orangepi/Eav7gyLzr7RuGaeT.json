{"updatedAt":"2026-01-02T07:12:30.330Z","createdAt":"2026-01-02T01:24:36.614Z","id":"Eav7gyLzr7RuGaeT","name":"Packet Processor with Quality Check","description":null,"active":true,"isArchived":false,"nodes":[{"name":"Webhook Trigger","type":"n8n-nodes-base.webhook","typeVersion":2,"position":[1728,5120],"parameters":{"httpMethod":"POST","path":"quality-check-packets","responseMode":"lastNode"},"disabled":false,"id":"4f49c6c8-7427-4b65-a070-aac57e8083ea"},{"parameters":{"options":{"reset":false}},"type":"n8n-nodes-base.splitInBatches","typeVersion":3,"position":[2448,5152],"id":"bbaf5f93-3e21-4e14-ab72-838ea2845dba","name":"Process Each Packet"},{"parameters":{"jsCode":"// Extract current packet\nconst packet = $input.all()[0].json;\n\n// Parse packetJSON if it's a string\nlet issueData = {};\ntry {\n  if (typeof packet.packetJSON === 'string') {\n    issueData = JSON.parse(packet.packetJSON);\n  } else if (packet.packetJSON) {\n    issueData = packet.packetJSON;\n  }\n} catch (e) {\n  issueData = {};\n}\n\n// Extract issue ID from issueIDs - MUST parse JSON string first!\nlet issueId = \"UNKNOWN\";\nlet issueIDs = packet.issueIDs || issueData.issueIDs || [];\n\n// Parse if it's a JSON string (e.g., '[\"GTE-308\"]')\nif (typeof issueIDs === 'string') {\n  try {\n    issueIDs = JSON.parse(issueIDs);\n  } catch (e) {\n    // If parse fails, treat as single ID string\n    issueIDs = [issueIDs];\n  }\n}\n\n// Now extract the first ID\nif (Array.isArray(issueIDs) && issueIDs.length > 0) {\n  issueId = issueIDs[0];\n} else if (typeof issueIDs === 'string' && issueIDs.length > 0) {\n  issueId = issueIDs;\n} else if (issueData.issueId) {\n  issueId = issueData.issueId;\n} else if (issueData.identifier) {\n  issueId = issueData.identifier;\n} else if (issueData.issues && issueData.issues.length > 0 && issueData.issues[0].id) {\n  // Fallback: get ID from issues array in packetJSON\n  issueId = issueData.issues[0].id;\n} else if (packet.packetID) {\n  issueId = packet.packetID;\n}\n\n// Extract title\nconst title = issueData.title || packet.title || issueData.name || \"Untitled\";\n\n// Extract description from issues array if available\nlet description = \"\";\nif (issueData.issues && issueData.issues.length > 0) {\n  description = issueData.issues[0].description || \"\";\n} else {\n  description = issueData.description || packet.description || \"\";\n}\n\n// Determine worker model\nconst assignedWorker = (packet.assignedWorker || \"primary_free\").toLowerCase();\nlet modelName = \"GPT-OSS-20b\";\n\nif (assignedWorker.includes(\"secondary\")) {\n  modelName = \"qwen3-vl-8b\";\n}\n\nreturn {\n  json: {\n    packetID: packet.packetID,\n    issueId: issueId,\n    title: title,\n    description: description,\n    acceptanceCriteria: issueData.acceptanceCriteria || \"\",\n    assignedWorker: packet.assignedWorker,\n    modelName: modelName,\n    _fullIssueData: issueData,\n    _originalPacket: packet\n  }\n};"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2720,5168],"id":"7b2f4b65-8533-4755-b4c9-cebd56198891","name":"Extract Packet Data"},{"parameters":{"jsCode":"const packet = $input.item.json;\n\nconst workPrompt = `You are an AI software developer processing a development issue.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nğŸ¯ ISSUE DETAILS\n\nIssue ID: ${packet.issueId}\nTitle: ${packet.title}\n\nDescription:\n${packet.description}\n\n${packet.acceptanceCriteria ? 'Acceptance Criteria:\\n' + packet.acceptanceCriteria + '\\n' : ''}\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nğŸ“‹ YOUR TASK\n\nPlease provide a complete implementation including:\n\n1. **Implementation**: Full code files with complete content (no placeholders!)\n2. **Testing**: Test cases and testing approach\n3. **Metadata**: Assumptions, dependencies, next steps\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nIMPORTANT:\n- Write complete code (this will be reviewed before deployment) (not snippets or TODOs)\n- Include all necessary imports and dependencies\n- Consider edge cases and error handling\n- Provide actual working code that can be used\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nNow process this issue and provide your implementation:\n`;\n\nreturn {\n  json: {\n    ...packet,\n    workPrompt: workPrompt\n  }\n};"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2960,5168],"id":"d69dbad0-12e3-4007-b8b5-24e2905da916","name":"Format Work Prompt"},{"parameters":{"promptType":"define","text":"={{ $json.workPrompt }}","options":{"systemMessage":"You are an expert software developer. Provide complete, working implementations. No placeholders, no TODOs. This code will be reviewed and tested before deployment.","maxIterations":10}},"type":"@n8n/n8n-nodes-langchain.agent","typeVersion":3,"position":[3120,5168],"id":"4e986e33-ecf0-4d28-81cb-59157a794d00","name":"Worker Agent"},{"parameters":{"model":{"__rl":true,"value":"openai/gpt-oss-20b","mode":"list","cachedResultName":"openai/gpt-oss-20b"},"responsesApiEnabled":false,"options":{"timeout":120000}},"type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","typeVersion":1.3,"position":[3104,5376],"id":"ef8aab0b-6d46-48f2-a3da-d1ae7533c8a9","name":"GPT-OSS-20b Model","credentials":{"openAiApi":{"id":"HE8StVq6t0epqs8Q","name":"BEAST LMStudio"}}},{"parameters":{"operation":"get","dataTableId":{"__rl":true,"value":"uY29FyKg9JFPZa9a","mode":"list","cachedResultName":"ClaudiaCodeIssuePackets","cachedResultUrl":"/projects/CDNyPtsGxHdhfdhy/datatables/uY29FyKg9JFPZa9a"},"returnAll":true},"type":"n8n-nodes-base.dataTable","typeVersion":1,"position":[2144,5136],"id":"9121d566-be75-4891-aea8-cb6029f5eb4e","name":"Get row(s)"},{"parameters":{"jsCode":"// Get original packet data (preserved from Extract Packet Data)\nconst originalPacket = $('Extract Packet Data').item.json;\n// Get Worker Agent output\nconst workerOutput = $input.item.json.output || \"\";\n\nconst validationPrompt = `You are an EXTREMELY STRICT Code Quality Validator with VERY HIGH STANDARDS.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nTask: ${originalPacket.issueId} - ${originalPacket.title}\n${originalPacket.description}\n\nGenerated Implementation:\n${workerOutput}\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nSTRICT QUALITY CRITERIA (0-100 each):\n\n1. COMPLETENESS (0-100):\n   - All requirements implemented? (not just mentioned)\n   - No TODOs or placeholders?\n   - No \"implement this later\" comments?\n   - All edge cases handled?\n\n2. CORRECTNESS (0-100):\n   - Logic is sound and bug-free?\n   - No obvious errors or issues?\n   - Code actually works as intended?\n   - No logical flaws?\n\n3. CODE QUALITY (0-100):\n   - Has error handling (try/catch, validation)?\n   - Has input validation?\n   - Clear variable names?\n   - No magic numbers?\n   - Well-structured and readable?\n\n4. TESTING (0-100):\n   - Has actual working tests?\n   - Tests cover main functionality?\n   - Tests include edge cases?\n   - Tests actually run?\n\n5. DOCUMENTATION (0-100):\n   - Clear docstrings/comments?\n   - Explains WHY not just WHAT?\n   - Usage examples?\n\n6. SECURITY (0-100):\n   - Input sanitized?\n   - No injection vulnerabilities?\n   - Safe patterns used?\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nSCORING RULES:\n- 90-100: Excellent, production-ready\n- 70-89: Good, minor issues only\n- 50-69: Needs improvement, has issues\n- 0-49: Poor, needs major rework\n\nCalculate OVERALL_SCORE as weighted average:\n- Completeness: 25%\n- Correctness: 25%\n- Code Quality: 20%\n- Testing: 15%\n- Documentation: 10%\n- Security: 5%\n\nDECISION RULES:\n- APPROVE: overall_score >= 85 AND no critical issues\n- FIX: 50 <= overall_score < 85 (fixable issues)\n- REJECT: overall_score < 50 (fundamental problems)\n\nReturn ONLY valid JSON:\n{\n  \"overall_score\": <0-100>,\n  \"completeness\": <0-100>,\n  \"correctness\": <0-100>,\n  \"code_quality\": <0-100>,\n  \"testing\": <0-100>,\n  \"documentation\": <0-100>,\n  \"security\": <0-100>,\n  \"decision\": \"APPROVE\" | \"FIX\" | \"REJECT\",\n  \"reasoning\": \"<1-2 sentences>\",\n  \"critical_issues\": [\"<issue1>\", ...],\n  \"minor_issues\": [\"<issue1>\", ...],\n  \"next_steps\": [\"<step1>\", ...]\n}\n`;\n\nreturn {\n  json: {\n    ...originalPacket,\n    generatedOutput: workerOutput,\n    validationPrompt: validationPrompt\n  }\n};"},"name":"Build Quality Check Prompt","type":"n8n-nodes-base.code","typeVersion":2,"position":[1072,4720],"id":"fa423063-644d-4d6d-b2a6-eedf40bf4372"},{"parameters":{"promptType":"define","text":"={{ $json.validationPrompt }}","options":{"systemMessage":"You are an EXTREMELY STRICT code quality validator. You have VERY HIGH STANDARDS.\n\nCRITICAL REVIEW RULES:\n- Code must be COMPLETE (no TODOs, no placeholders, no \"implement this later\")\n- Code must be CORRECT (logic must be sound and bug-free)\n- Code must have ERROR HANDLING (try/catch, input validation, edge cases)\n- Code must have TESTS (actual working tests, not just comments)\n- Code must have DOCUMENTATION (clear docstrings/comments)\n- Code must be SECURE (no SQL injection, XSS, or other vulnerabilities)\n- Code must be PRODUCTION-QUALITY (not just \"good enough\")\n\nDO NOT ACCEPT:\n- Code with placeholder comments\n- Code without error handling\n- Code without input validation\n- Code without tests\n- Code with poor variable names\n- Code with magic numbers\n- Code with security issues\n\nBe HARSH but CONSTRUCTIVE. Identify EVERY issue. Demand EXCELLENCE.\n\nReturn ONLY valid JSON with your strict assessment.","maxIterations":5}},"name":"Quality Validator","type":"@n8n/n8n-nodes-langchain.agent","typeVersion":1.7,"position":[1200,4512],"id":"1829daab-0669-4eea-bbad-dc588b59237c"},{"parameters":{"model":{"__rl":true,"mode":"list","value":"qwen/qwen3-vl-8b"},"builtInTools":{},"options":{"timeout":120000}},"name":"Validator Model","type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","typeVersion":1.3,"position":[1280,4928],"id":"ad6a322f-30b3-4552-990a-15c7a6de2cf6","credentials":{"openAiApi":{"id":"FYFVsKzjVFK0h0V2","name":"Bedroom LMStudio"}}},{"parameters":{"jsCode":"// Get original packet data\nconst originalPacket = $('Extract Packet Data').item.json;\n// Get the current flow data (includes generatedOutput from Build Quality Check Prompt)\nconst flowData = $('Build Quality Check Prompt').item.json;\n// Get validator output\nconst validatorOutput = $input.item.json.output || \"\";\n\nlet qualityReport;\ntry {\n  const jsonMatch = validatorOutput.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    qualityReport = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('No JSON found');\n  }\n} catch (e) {\n  qualityReport = {\n    overall_score: 50,\n    completeness: 50,\n    correctness: 50,\n    code_quality: 50,\n    testing: 50,\n    documentation: 50,\n    security: 50,\n    decision: 'FIX',\n    reasoning: 'Validator failed to produce valid JSON: ' + e.message,\n    critical_issues: ['Validator output format error'],\n    minor_issues: [],\n    next_steps: ['Fix validator output format']\n  };\n}\n\n// Ensure all expected fields exist\nconst defaults = {\n  overall_score: 50,\n  completeness: 50,\n  correctness: 50,\n  code_quality: 50,\n  testing: 50,\n  documentation: 50,\n  security: 50,\n  decision: 'FIX',\n  reasoning: 'No reasoning provided',\n  critical_issues: [],\n  minor_issues: [],\n  next_steps: []\n};\n\nfor (const key of Object.keys(defaults)) {\n  if (qualityReport[key] === undefined) {\n    qualityReport[key] = defaults[key];\n  }\n}\n\n// Calculate iteration - get from original packet or default to 0\nconst currentIteration = originalPacket.iteration || flowData.iteration || 0;\n\nreturn {\n  json: {\n    // Preserve original packet fields\n    ...originalPacket,\n    // Add generated output\n    generatedOutput: flowData.generatedOutput,\n    // Add quality fields\n    qualityScore: qualityReport.overall_score,\n    decision: qualityReport.decision,\n    qualityReport: qualityReport,\n    qualityNextSteps: qualityReport.next_steps || [],\n    iteration: currentIteration + 1,\n    maxIterations: 5\n  }\n};"},"name":"Parse Quality Score","type":"n8n-nodes-base.code","typeVersion":2,"position":[1472,4720],"id":"0d1641bd-5014-4a9d-8440-ff346db0c170"},{"parameters":{"conditions":{"boolean":[{"value1":"={{ $json.validationPassed }}","operation":"true"}]},"options":{}},"name":"Decision Router","type":"n8n-nodes-base.if","typeVersion":2,"position":[3280,4720],"id":"c0cad35e-1022-4145-9c8e-e8e5ccf385e3"},{"parameters":{"jsCode":"const fs = require('fs');\nconst path = require('path');\nconst packet = $input.item.json;\n\nconst now = new Date();\nconst timestamp = now.toISOString().replace(/[:.]/g, '-');\n\n// Get issueId - it should now be properly preserved through the pipeline\nconst issueId = packet.issueId || packet.packetID || 'unknown';\nconst title = packet.title || 'Untitled';\nconst titleClean = title.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50);\n\n// Get generated code from multiple possible locations\nconst generatedCode = packet.improvedCode\n  || packet.generatedOutput\n  || packet.codeToTest\n  || packet.output\n  || '(no code generated)';\n\nconst filename = `${issueId}-${titleClean}-${timestamp}.md`;\nconst filePath = `/mnt/n8n-nas/packet_outputs/generated_code/${filename}`;\n\n// Build markdown\nconst parts = [];\nparts.push(`# ${issueId}: ${title}`);\nparts.push('');\nparts.push(`**Issue ID:** ${issueId}`);\nparts.push(`**Packet ID:** ${packet.packetID || 'N/A'}`);\nparts.push(`**Quality Score:** ${packet.qualityScore || 0}/100`);\nparts.push(`**Final Score:** ${packet.finalScore || packet.qualityScore || 0}/100`);\nparts.push(`**Iterations:** ${packet.iteration || 1}`);\nparts.push(`**Timestamp:** ${now.toISOString()}`);\nparts.push(`**Status:** Accepted`);\nparts.push('');\nparts.push('## Implementation');\nparts.push('');\nparts.push('```json');\nparts.push(generatedCode);\nparts.push('```');\nparts.push('');\nparts.push('## Quality Report');\nparts.push('');\ntry {\n  parts.push(JSON.stringify(packet.qualityReport || {}, null, 2));\n} catch (e) {\n  parts.push('{}');\n}\nparts.push('');\nparts.push('---');\nparts.push('*Generated by Packet Processor workflow*');\n\nconst markdown = parts.join('\\n');\n\n// Ensure directory exists\nconst dir = path.dirname(filePath);\nif (!fs.existsSync(dir)) {\n  fs.mkdirSync(dir, { recursive: true });\n}\n\n// Write file\nfs.writeFileSync(filePath, markdown, 'utf8');\n\nreturn {\n  json: {\n    success: true,\n    filePath: filePath,\n    filename: filename,\n    issueId: issueId,\n    packetID: packet.packetID,\n    finalScore: packet.finalScore || packet.qualityScore\n  }\n};"},"name":"Save Accepted Output","type":"n8n-nodes-base.code","typeVersion":2,"position":[3680,4624],"id":"9aa6e523-c746-41e1-a0ef-8683be163900"},{"parameters":{"conditions":{"number":[{"value1":"={{ $json.iteration }}","operation":"largerEqual","value2":"={{ $json.maxIterations }}"}]},"options":{}},"name":"Check Max Iterations","type":"n8n-nodes-base.if","typeVersion":2,"position":[3680,4832],"id":"e575ea55-6001-4cbb-999d-e84c70697c40"},{"parameters":{},"name":"Loop Back","type":"n8n-nodes-base.noOp","typeVersion":1,"position":[3888,4928],"id":"e35bbf95-f550-4a90-902e-3986f96a82af"},{"parameters":{"jsCode":"// Get original packet data\nconst originalPacket = $('Extract Packet Data').item.json;\n// Get flow data with quality results\nconst flowData = $input.item.json;\nconst generatedCode = flowData.generatedOutput || \"\";\n\n// Determine language\nlet language = 'python';\nif (generatedCode.includes('import ') || generatedCode.includes('def ')) {\n  language = 'python';\n} else if (generatedCode.includes('function ') || generatedCode.includes('const ') || generatedCode.includes('let ')) {\n  language = 'javascript';\n} else if (generatedCode.includes('package ') || generatedCode.includes('func ')) {\n  language = 'go';\n}\n\n// Check if it has test cases\nconst hasTests = generatedCode.includes('test_') ||\n                 generatedCode.includes('describe(') ||\n                 generatedCode.includes('it(') ||\n                 generatedCode.includes('assert');\n\nreturn {\n  json: {\n    // Preserve original packet and flow data\n    ...flowData,\n    // Ensure original packet fields are present\n    issueId: originalPacket.issueId,\n    title: originalPacket.title,\n    description: originalPacket.description,\n    packetID: originalPacket.packetID,\n    // Add test extraction results\n    language: language,\n    hasTests: hasTests,\n    codeToTest: generatedCode\n  }\n};"},"name":"Extract Test Requirements","type":"n8n-nodes-base.code","typeVersion":2,"position":[2064,4544],"id":"b7c5f6df-b7eb-4e8f-b127-b9ccc2420b48"},{"parameters":{"jsCode":"const { execSync } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\nconst packet = $input.item.json;\n\n// Create temporary directory\nconst tmpDir = `/tmp/code-test-${Date.now()}`;\nfs.mkdirSync(tmpDir, { recursive: true });\n\nlet testResults = {\n  passed: false,\n  output: '',\n  error: '',\n  exitCode: -1,\n  duration: 0\n};\n\nconst startTime = Date.now();\n\ntry {\n  const codeToTest = packet.codeToTest || '';\n  const language = packet.language || 'unknown';\n\n  if (!codeToTest) {\n    throw new Error('No code to test');\n  }\n\n  if (language === 'python') {\n    // Write code to file\n    const codeFile = path.join(tmpDir, 'test_code.py');\n    fs.writeFileSync(codeFile, codeToTest, 'utf8');\n\n    // Run with timeout\n    const output = execSync(`python3 ${codeFile}`, {\n      cwd: tmpDir,\n      timeout: 30000,\n      encoding: 'utf8',\n      env: { ...process.env, PYTHONDONTWRITEBYTECODE: '1' }\n    });\n\n    testResults.passed = true;\n    testResults.output = output;\n    testResults.exitCode = 0;\n\n  } else if (language === 'javascript') {\n    // Write code to file\n    const codeFile = path.join(tmpDir, 'test_code.js');\n    fs.writeFileSync(codeFile, codeToTest, 'utf8');\n\n    // Run with Node.js\n    const output = execSync(`node ${codeFile}`, {\n      cwd: tmpDir,\n      timeout: 30000,\n      encoding: 'utf8'\n    });\n\n    testResults.passed = true;\n    testResults.output = output;\n    testResults.exitCode = 0;\n\n  } else {\n    // Unknown language - mark as skipped\n    testResults.passed = false;\n    testResults.error = `Testing not supported for language: ${language}`;\n    testResults.exitCode = -2;\n  }\n\n} catch (error) {\n  testResults.passed = false;\n  testResults.error = error.message || String(error);\n  testResults.output = error.stdout || '';\n  testResults.exitCode = error.status || -1;\n} finally {\n  testResults.duration = Date.now() - startTime;\n\n  // Cleanup\n  try {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  } catch (cleanupError) {\n    // Ignore cleanup errors\n  }\n}\n\nreturn {\n  json: {\n    ...packet,\n    testResults: testResults,\n    testedAt: new Date().toISOString()\n  }\n};"},"name":"Run Code Tests","type":"n8n-nodes-base.code","typeVersion":2,"position":[2256,4544],"id":"7c009b2c-0c2c-4c98-bb15-3bcf653b7016"},{"parameters":{"jsCode":"// Get original packet data\nconst originalPacket = $('Extract Packet Data').item.json;\n// Get flow data with test results\nconst flowData = $input.item.json;\nconst testResults = flowData.testResults || { passed: false, output: '', error: 'No test results' };\nconst qualityIssues = flowData.qualityReport?.critical_issues || [];\nconst nextSteps = flowData.qualityReport?.next_steps || [];\n\n// Build critical issues list\nlet criticalIssuesList = 'None identified';\nif (qualityIssues.length > 0) {\n  criticalIssuesList = qualityIssues.map((issue, i) => `${i + 1}. ${issue}`).join('\\n');\n}\n\n// Build next steps list\nlet nextStepsList = 'None identified';\nif (nextSteps.length > 0) {\n  nextStepsList = nextSteps.map((step, i) => `${i + 1}. ${step}`).join('\\n');\n}\n\n// Build test status\nconst testStatus = testResults.passed ? 'âœ… PASSED' : 'âŒ FAILED';\nconst testOutput = testResults.output || '(none)';\nconst testError = testResults.error ? `Error: ${testResults.error}` : '';\n\n// Build the prompt parts\nconst promptParts = [];\npromptParts.push('You are a PROACTIVE Code Editor. Your job is to FIX issues, not just identify them.');\npromptParts.push('');\npromptParts.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\npromptParts.push('');\npromptParts.push(`ğŸ“‹ TASK: ${originalPacket.issueId} - ${originalPacket.title}`);\npromptParts.push('');\npromptParts.push('ğŸ“ CURRENT CODE:');\npromptParts.push('```');\npromptParts.push(flowData.codeToTest || '(no code)');\npromptParts.push('```');\npromptParts.push('');\npromptParts.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\npromptParts.push('');\npromptParts.push(`ğŸ§ª TEST RESULTS: ${testStatus}`);\npromptParts.push('');\npromptParts.push('Output:');\npromptParts.push(testOutput);\nif (testError) {\n  promptParts.push('');\n  promptParts.push(testError);\n}\npromptParts.push('');\npromptParts.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\npromptParts.push('');\npromptParts.push(`ğŸ“Š QUALITY SCORE: ${flowData.qualityScore || 0}/100`);\npromptParts.push('');\npromptParts.push('Critical Issues:');\npromptParts.push(criticalIssuesList);\npromptParts.push('');\npromptParts.push('Required Fixes:');\npromptParts.push(nextStepsList);\npromptParts.push('');\npromptParts.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\npromptParts.push('');\npromptParts.push('YOUR MISSION:');\npromptParts.push('1. FIX all test failures');\npromptParts.push('2. FIX all critical issues');\npromptParts.push('3. ADD missing error handling');\npromptParts.push('4. ADD missing tests');\npromptParts.push('5. IMPROVE code quality');\npromptParts.push('');\npromptParts.push('Return ONLY valid JSON:');\npromptParts.push('{');\npromptParts.push('  \"decision\": \"APPROVE\" | \"ITERATE\" | \"REJECT\",');\npromptParts.push('  \"editor_score\": <0-100>,');\npromptParts.push('  \"improved_code\": \"<complete improved code>\",');\npromptParts.push('  \"fixes_applied\": [\"<fix1>\", ...],');\npromptParts.push('  \"tests_added\": [\"<test1>\", ...],');\npromptParts.push('  \"error_handling_added\": [\"<handler1>\", ...],');\npromptParts.push('  \"docs_added\": [\"<doc1>\", ...],');\npromptParts.push('  \"remaining_issues\": [\"<issue1>\", ...]');\npromptParts.push('}');\n\nconst editorPrompt = promptParts.join('\\n');\n\nreturn {\n  json: {\n    // Preserve all flow data\n    ...flowData,\n    // Ensure original packet fields are present\n    issueId: originalPacket.issueId,\n    title: originalPacket.title,\n    description: originalPacket.description,\n    packetID: originalPacket.packetID,\n    // Add editor prompt\n    editorPrompt: editorPrompt\n  }\n};"},"name":"Build Editor Prompt","type":"n8n-nodes-base.code","typeVersion":2,"position":[2464,4544],"id":"6716acd8-623b-48c4-b5df-021763f1c27d"},{"parameters":{"promptType":"define","text":"={{ $json.editorPrompt }}","options":{"systemMessage":"You are a PROACTIVE Code Editor. You don't just review - you FIX and IMPROVE.\n\nYOUR JOB:\n1. Review test execution results\n2. FIX any errors you find (don't just identify them!)\n3. ADD missing error handling\n4. ADD missing tests\n5. ADD missing documentation\n6. IMPROVE code quality\n7. Only APPROVE after you've made it EXCELLENT\n\nYOU CAN AND SHOULD:\n- Fix bugs and errors\n- Add try/catch blocks\n- Add input validation\n- Add test assertions\n- Add docstrings and comments\n- Improve variable names\n- Remove code smells\n\nDO NOT just say \"needs error handling\" - ADD the error handling!\nDO NOT just say \"needs tests\" - ADD the tests!\nDO NOT just say \"needs docs\" - ADD the documentation!\n\nOnly return APPROVE after you've actually FIXED everything.\n\nReturn ONLY valid JSON with your improvements.","maxIterations":5}},"name":"Editor Validator","type":"@n8n/n8n-nodes-langchain.agent","typeVersion":1.7,"position":[2656,4544],"id":"ea0d12d5-6f70-49a7-afe1-52a4554b1a8d"},{"parameters":{"model":{"__rl":true,"mode":"list","value":"mistralai/ministral-3-3b"},"builtInTools":{},"options":{"timeout":60000}},"name":"Editor Model","type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","typeVersion":1.3,"position":[2656,4752],"id":"19100908-42fa-4589-b80a-1c5cda4d2c91","credentials":{"openAiApi":{"id":"FYFVsKzjVFK0h0V2","name":"Bedroom LMStudio"}}},{"parameters":{"jsCode":"// Get original packet data\nconst originalPacket = $('Extract Packet Data').item.json;\n// Get flow data\nconst flowData = $('Build Editor Prompt').item.json;\n// Get editor output\nconst editorOutput = $input.item.json.output || \"\";\n\nlet editorDecision;\ntry {\n  const jsonMatch = editorOutput.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    editorDecision = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('No JSON found in editor output');\n  }\n} catch (e) {\n  // Fallback based on test results\n  const testPassed = flowData.testResults?.passed || false;\n  editorDecision = {\n    decision: 'ITERATE',\n    editor_score: testPassed ? 60 : 30,\n    improved_code: flowData.codeToTest || '',\n    fixes_applied: [],\n    tests_added: [],\n    error_handling_added: [],\n    docs_added: [],\n    remaining_issues: ['Editor failed to parse JSON - needs retry: ' + e.message],\n    reasoning: 'Editor output parse error'\n  };\n}\n\n// Use improved code if provided\nconst finalCode = editorDecision.improved_code || flowData.codeToTest || '';\n\n// Quality (30%) + Editor (70%) - Editor is MORE important now\nconst qualityScore = flowData.qualityScore || 50;\nconst editorScore = editorDecision.editor_score || 0;\nconst finalScore = Math.floor((qualityScore * 0.3) + (editorScore * 0.7));\n\n// Higher bar: need 85+ to approve\nconst validationPassed = editorDecision.decision === 'APPROVE' && finalScore >= 85;\n\nreturn {\n  json: {\n    // Preserve original packet fields (CRITICAL for Save Accepted Output)\n    issueId: originalPacket.issueId,\n    title: originalPacket.title,\n    description: originalPacket.description,\n    packetID: originalPacket.packetID,\n    // Preserve flow data\n    generatedOutput: flowData.generatedOutput,\n    codeToTest: flowData.codeToTest,\n    qualityScore: qualityScore,\n    qualityReport: flowData.qualityReport,\n    testResults: flowData.testResults,\n    iteration: flowData.iteration,\n    maxIterations: flowData.maxIterations,\n    // Add editor results\n    improvedCode: finalCode,\n    editorDecision: editorDecision.decision,\n    editorScore: editorScore,\n    finalScore: finalScore,\n    fixesApplied: editorDecision.fixes_applied || [],\n    testsAdded: editorDecision.tests_added || [],\n    errorHandlingAdded: editorDecision.error_handling_added || [],\n    docsAdded: editorDecision.docs_added || [],\n    remainingIssues: editorDecision.remaining_issues || [],\n    // Decision for router\n    validationPassed: validationPassed\n  }\n};"},"name":"Parse Editor Decision","type":"n8n-nodes-base.code","typeVersion":2,"position":[3008,4544],"id":"a8cd17e2-11b5-44d4-995d-92360e060e8a"},{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[1904,5152],"id":"7f262816-8f96-41a5-8776-0cf38cb1ab0e","name":"When clicking â€˜Execute workflowâ€™"}],"connections":{"Process Each Packet":{"main":[[],[{"node":"Extract Packet Data","type":"main","index":0}]]},"Extract Packet Data":{"main":[[{"node":"Format Work Prompt","type":"main","index":0}]]},"Format Work Prompt":{"main":[[{"node":"Worker Agent","type":"main","index":0}]]},"Worker Agent":{"main":[[{"node":"Build Quality Check Prompt","type":"main","index":0}]]},"GPT-OSS-20b Model":{"ai_languageModel":[[{"node":"Worker Agent","type":"ai_languageModel","index":0}]]},"Get row(s)":{"main":[[{"node":"Process Each Packet","type":"main","index":0}]]},"Build Quality Check Prompt":{"main":[[{"node":"Quality Validator","type":"main","index":0}]]},"Validator Model":{"ai_languageModel":[[{"node":"Quality Validator","type":"ai_languageModel","index":0}]]},"Quality Validator":{"main":[[{"node":"Parse Quality Score","type":"main","index":0}]]},"Parse Quality Score":{"main":[[{"node":"Extract Test Requirements","type":"main","index":0}]]},"Decision Router":{"main":[[{"node":"Save Accepted Output","type":"main","index":0}],[{"node":"Check Max Iterations","type":"main","index":0}]]},"Save Accepted Output":{"main":[[{"node":"Process Each Packet","type":"main","index":0}]]},"Check Max Iterations":{"main":[[{"node":"Process Each Packet","type":"main","index":0}],[{"node":"Loop Back","type":"main","index":0}]]},"Loop Back":{"main":[[{"node":"Format Work Prompt","type":"main","index":0}]]},"When clicking â€˜Execute workflowâ€™":{"main":[[{"node":"Get row(s)","type":"main","index":0}]]},"Extract Test Requirements":{"main":[[{"node":"Run Code Tests","type":"main","index":0}]]},"Run Code Tests":{"main":[[{"node":"Build Editor Prompt","type":"main","index":0}]]},"Build Editor Prompt":{"main":[[{"node":"Editor Validator","type":"main","index":0}]]},"Editor Model":{"ai_languageModel":[[{"node":"Editor Validator","type":"ai_languageModel","index":0}]]},"Editor Validator":{"main":[[{"node":"Parse Editor Decision","type":"main","index":0}]]},"Parse Editor Decision":{"main":[[{"node":"Decision Router","type":"main","index":0}]]},"Webhook Trigger":{"main":[[{"node":"Get row(s)","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","callerPolicy":"workflowsFromSameOwner","availableInMCP":false},"staticData":null,"meta":null,"pinData":{},"versionId":"d212309a-2ff1-40ee-b24e-8b64888bc99e","activeVersionId":"d212309a-2ff1-40ee-b24e-8b64888bc99e","versionCounter":75,"triggerCount":1,"shared":[{"updatedAt":"2026-01-02T01:24:36.618Z","createdAt":"2026-01-02T01:24:36.618Z","role":"workflow:owner","workflowId":"Eav7gyLzr7RuGaeT","projectId":"CDNyPtsGxHdhfdhy","project":{"updatedAt":"2025-12-18T17:16:03.660Z","createdAt":"2025-12-18T17:12:50.624Z","id":"CDNyPtsGxHdhfdhy","name":"Bill Griffith <bill@gtechsd.com>","type":"personal","icon":null,"description":null,"projectRelations":[{"updatedAt":"2025-12-18T17:12:50.625Z","createdAt":"2025-12-18T17:12:50.625Z","userId":"82ee42c3-23a4-46d2-8969-bfa414e739d3","projectId":"CDNyPtsGxHdhfdhy","user":{"updatedAt":"2026-01-09T00:29:59.000Z","createdAt":"2025-12-18T17:12:49.746Z","id":"82ee42c3-23a4-46d2-8969-bfa414e739d3","email":"bill@gtechsd.com","firstName":"Bill","lastName":"Griffith","personalizationAnswers":{"version":"v4","personalization_survey_submitted_at":"2025-12-18T17:16:08.098Z","personalization_survey_n8n_version":"2.0.3"},"settings":{"userActivated":true,"easyAIWorkflowOnboarded":true,"firstSuccessfulWorkflowId":"ud7XYHk6QWFvgDxf","userActivatedAt":1766585292861,"npsSurvey":{"waitingForResponse":true,"ignoredCount":1,"lastShownAt":1766866231466}},"disabled":false,"mfaEnabled":false,"lastActiveAt":"2026-01-08","isPending":false}}]}}],"tags":[{"updatedAt":"2026-01-01T23:41:10.347Z","createdAt":"2026-01-01T23:41:10.347Z","id":"59v2I1DDZaqntzwf","name":"AI GENERATED"},{"updatedAt":"2026-01-01T23:43:52.148Z","createdAt":"2026-01-01T23:43:52.148Z","id":"MYeI4rvwznCZuMBg","name":"WORKING"},{"updatedAt":"2026-01-01T23:43:35.790Z","createdAt":"2026-01-01T23:43:35.790Z","id":"dzJsfxOIBt7NDFJ8","name":"LATEST VERSION"},{"updatedAt":"2026-01-01T23:47:23.414Z","createdAt":"2026-01-01T23:47:23.414Z","id":"e9wyuzgPFWT6vuEp","name":"HAS ISSUES"},{"updatedAt":"2026-01-01T23:44:48.788Z","createdAt":"2026-01-01T23:44:48.788Z","id":"l6FVWknceeDeKEoz","name":"SANDBOX"}],"activeVersion":{"updatedAt":"2026-01-02T07:12:30.333Z","createdAt":"2026-01-02T07:12:30.333Z","versionId":"d212309a-2ff1-40ee-b24e-8b64888bc99e","workflowId":"Eav7gyLzr7RuGaeT","nodes":[{"name":"Webhook Trigger","type":"n8n-nodes-base.webhook","typeVersion":2,"position":[1728,5120],"parameters":{"httpMethod":"POST","path":"quality-check-packets","responseMode":"lastNode"},"disabled":false,"id":"4f49c6c8-7427-4b65-a070-aac57e8083ea"},{"parameters":{"options":{"reset":false}},"type":"n8n-nodes-base.splitInBatches","typeVersion":3,"position":[2448,5152],"id":"bbaf5f93-3e21-4e14-ab72-838ea2845dba","name":"Process Each Packet"},{"parameters":{"jsCode":"// Extract current packet\nconst packet = $input.all()[0].json;\n\n// Parse packetJSON if it's a string\nlet issueData = {};\ntry {\n  if (typeof packet.packetJSON === 'string') {\n    issueData = JSON.parse(packet.packetJSON);\n  } else if (packet.packetJSON) {\n    issueData = packet.packetJSON;\n  }\n} catch (e) {\n  issueData = {};\n}\n\n// Extract issue ID from issueIDs - MUST parse JSON string first!\nlet issueId = \"UNKNOWN\";\nlet issueIDs = packet.issueIDs || issueData.issueIDs || [];\n\n// Parse if it's a JSON string (e.g., '[\"GTE-308\"]')\nif (typeof issueIDs === 'string') {\n  try {\n    issueIDs = JSON.parse(issueIDs);\n  } catch (e) {\n    // If parse fails, treat as single ID string\n    issueIDs = [issueIDs];\n  }\n}\n\n// Now extract the first ID\nif (Array.isArray(issueIDs) && issueIDs.length > 0) {\n  issueId = issueIDs[0];\n} else if (typeof issueIDs === 'string' && issueIDs.length > 0) {\n  issueId = issueIDs;\n} else if (issueData.issueId) {\n  issueId = issueData.issueId;\n} else if (issueData.identifier) {\n  issueId = issueData.identifier;\n} else if (issueData.issues && issueData.issues.length > 0 && issueData.issues[0].id) {\n  // Fallback: get ID from issues array in packetJSON\n  issueId = issueData.issues[0].id;\n} else if (packet.packetID) {\n  issueId = packet.packetID;\n}\n\n// Extract title\nconst title = issueData.title || packet.title || issueData.name || \"Untitled\";\n\n// Extract description from issues array if available\nlet description = \"\";\nif (issueData.issues && issueData.issues.length > 0) {\n  description = issueData.issues[0].description || \"\";\n} else {\n  description = issueData.description || packet.description || \"\";\n}\n\n// Determine worker model\nconst assignedWorker = (packet.assignedWorker || \"primary_free\").toLowerCase();\nlet modelName = \"GPT-OSS-20b\";\n\nif (assignedWorker.includes(\"secondary\")) {\n  modelName = \"qwen3-vl-8b\";\n}\n\nreturn {\n  json: {\n    packetID: packet.packetID,\n    issueId: issueId,\n    title: title,\n    description: description,\n    acceptanceCriteria: issueData.acceptanceCriteria || \"\",\n    assignedWorker: packet.assignedWorker,\n    modelName: modelName,\n    _fullIssueData: issueData,\n    _originalPacket: packet\n  }\n};"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2720,5168],"id":"7b2f4b65-8533-4755-b4c9-cebd56198891","name":"Extract Packet Data"},{"parameters":{"jsCode":"const packet = $input.item.json;\n\nconst workPrompt = `You are an AI software developer processing a development issue.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nğŸ¯ ISSUE DETAILS\n\nIssue ID: ${packet.issueId}\nTitle: ${packet.title}\n\nDescription:\n${packet.description}\n\n${packet.acceptanceCriteria ? 'Acceptance Criteria:\\n' + packet.acceptanceCriteria + '\\n' : ''}\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nğŸ“‹ YOUR TASK\n\nPlease provide a complete implementation including:\n\n1. **Implementation**: Full code files with complete content (no placeholders!)\n2. **Testing**: Test cases and testing approach\n3. **Metadata**: Assumptions, dependencies, next steps\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nIMPORTANT:\n- Write complete code (this will be reviewed before deployment) (not snippets or TODOs)\n- Include all necessary imports and dependencies\n- Consider edge cases and error handling\n- Provide actual working code that can be used\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nNow process this issue and provide your implementation:\n`;\n\nreturn {\n  json: {\n    ...packet,\n    workPrompt: workPrompt\n  }\n};"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2960,5168],"id":"d69dbad0-12e3-4007-b8b5-24e2905da916","name":"Format Work Prompt"},{"parameters":{"promptType":"define","text":"={{ $json.workPrompt }}","options":{"systemMessage":"You are an expert software developer. Provide complete, working implementations. No placeholders, no TODOs. This code will be reviewed and tested before deployment.","maxIterations":10}},"type":"@n8n/n8n-nodes-langchain.agent","typeVersion":3,"position":[3120,5168],"id":"4e986e33-ecf0-4d28-81cb-59157a794d00","name":"Worker Agent"},{"parameters":{"model":{"__rl":true,"value":"openai/gpt-oss-20b","mode":"list","cachedResultName":"openai/gpt-oss-20b"},"responsesApiEnabled":false,"options":{"timeout":120000}},"type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","typeVersion":1.3,"position":[3104,5376],"id":"ef8aab0b-6d46-48f2-a3da-d1ae7533c8a9","name":"GPT-OSS-20b Model","credentials":{"openAiApi":{"id":"HE8StVq6t0epqs8Q","name":"BEAST LMStudio"}}},{"parameters":{"operation":"get","dataTableId":{"__rl":true,"value":"uY29FyKg9JFPZa9a","mode":"list","cachedResultName":"ClaudiaCodeIssuePackets","cachedResultUrl":"/projects/CDNyPtsGxHdhfdhy/datatables/uY29FyKg9JFPZa9a"},"returnAll":true},"type":"n8n-nodes-base.dataTable","typeVersion":1,"position":[2144,5136],"id":"9121d566-be75-4891-aea8-cb6029f5eb4e","name":"Get row(s)"},{"parameters":{"jsCode":"// Get original packet data (preserved from Extract Packet Data)\nconst originalPacket = $('Extract Packet Data').item.json;\n// Get Worker Agent output\nconst workerOutput = $input.item.json.output || \"\";\n\nconst validationPrompt = `You are an EXTREMELY STRICT Code Quality Validator with VERY HIGH STANDARDS.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nTask: ${originalPacket.issueId} - ${originalPacket.title}\n${originalPacket.description}\n\nGenerated Implementation:\n${workerOutput}\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nSTRICT QUALITY CRITERIA (0-100 each):\n\n1. COMPLETENESS (0-100):\n   - All requirements implemented? (not just mentioned)\n   - No TODOs or placeholders?\n   - No \"implement this later\" comments?\n   - All edge cases handled?\n\n2. CORRECTNESS (0-100):\n   - Logic is sound and bug-free?\n   - No obvious errors or issues?\n   - Code actually works as intended?\n   - No logical flaws?\n\n3. CODE QUALITY (0-100):\n   - Has error handling (try/catch, validation)?\n   - Has input validation?\n   - Clear variable names?\n   - No magic numbers?\n   - Well-structured and readable?\n\n4. TESTING (0-100):\n   - Has actual working tests?\n   - Tests cover main functionality?\n   - Tests include edge cases?\n   - Tests actually run?\n\n5. DOCUMENTATION (0-100):\n   - Clear docstrings/comments?\n   - Explains WHY not just WHAT?\n   - Usage examples?\n\n6. SECURITY (0-100):\n   - Input sanitized?\n   - No injection vulnerabilities?\n   - Safe patterns used?\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nSCORING RULES:\n- 90-100: Excellent, production-ready\n- 70-89: Good, minor issues only\n- 50-69: Needs improvement, has issues\n- 0-49: Poor, needs major rework\n\nCalculate OVERALL_SCORE as weighted average:\n- Completeness: 25%\n- Correctness: 25%\n- Code Quality: 20%\n- Testing: 15%\n- Documentation: 10%\n- Security: 5%\n\nDECISION RULES:\n- APPROVE: overall_score >= 85 AND no critical issues\n- FIX: 50 <= overall_score < 85 (fixable issues)\n- REJECT: overall_score < 50 (fundamental problems)\n\nReturn ONLY valid JSON:\n{\n  \"overall_score\": <0-100>,\n  \"completeness\": <0-100>,\n  \"correctness\": <0-100>,\n  \"code_quality\": <0-100>,\n  \"testing\": <0-100>,\n  \"documentation\": <0-100>,\n  \"security\": <0-100>,\n  \"decision\": \"APPROVE\" | \"FIX\" | \"REJECT\",\n  \"reasoning\": \"<1-2 sentences>\",\n  \"critical_issues\": [\"<issue1>\", ...],\n  \"minor_issues\": [\"<issue1>\", ...],\n  \"next_steps\": [\"<step1>\", ...]\n}\n`;\n\nreturn {\n  json: {\n    ...originalPacket,\n    generatedOutput: workerOutput,\n    validationPrompt: validationPrompt\n  }\n};"},"name":"Build Quality Check Prompt","type":"n8n-nodes-base.code","typeVersion":2,"position":[1072,4720],"id":"fa423063-644d-4d6d-b2a6-eedf40bf4372"},{"parameters":{"promptType":"define","text":"={{ $json.validationPrompt }}","options":{"systemMessage":"You are an EXTREMELY STRICT code quality validator. You have VERY HIGH STANDARDS.\n\nCRITICAL REVIEW RULES:\n- Code must be COMPLETE (no TODOs, no placeholders, no \"implement this later\")\n- Code must be CORRECT (logic must be sound and bug-free)\n- Code must have ERROR HANDLING (try/catch, input validation, edge cases)\n- Code must have TESTS (actual working tests, not just comments)\n- Code must have DOCUMENTATION (clear docstrings/comments)\n- Code must be SECURE (no SQL injection, XSS, or other vulnerabilities)\n- Code must be PRODUCTION-QUALITY (not just \"good enough\")\n\nDO NOT ACCEPT:\n- Code with placeholder comments\n- Code without error handling\n- Code without input validation\n- Code without tests\n- Code with poor variable names\n- Code with magic numbers\n- Code with security issues\n\nBe HARSH but CONSTRUCTIVE. Identify EVERY issue. Demand EXCELLENCE.\n\nReturn ONLY valid JSON with your strict assessment.","maxIterations":5}},"name":"Quality Validator","type":"@n8n/n8n-nodes-langchain.agent","typeVersion":1.7,"position":[1200,4512],"id":"1829daab-0669-4eea-bbad-dc588b59237c"},{"parameters":{"model":{"__rl":true,"mode":"list","value":"qwen/qwen3-vl-8b"},"builtInTools":{},"options":{"timeout":120000}},"name":"Validator Model","type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","typeVersion":1.3,"position":[1280,4928],"id":"ad6a322f-30b3-4552-990a-15c7a6de2cf6","credentials":{"openAiApi":{"id":"FYFVsKzjVFK0h0V2","name":"Bedroom LMStudio"}}},{"parameters":{"jsCode":"// Get original packet data\nconst originalPacket = $('Extract Packet Data').item.json;\n// Get the current flow data (includes generatedOutput from Build Quality Check Prompt)\nconst flowData = $('Build Quality Check Prompt').item.json;\n// Get validator output\nconst validatorOutput = $input.item.json.output || \"\";\n\nlet qualityReport;\ntry {\n  const jsonMatch = validatorOutput.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    qualityReport = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('No JSON found');\n  }\n} catch (e) {\n  qualityReport = {\n    overall_score: 50,\n    completeness: 50,\n    correctness: 50,\n    code_quality: 50,\n    testing: 50,\n    documentation: 50,\n    security: 50,\n    decision: 'FIX',\n    reasoning: 'Validator failed to produce valid JSON: ' + e.message,\n    critical_issues: ['Validator output format error'],\n    minor_issues: [],\n    next_steps: ['Fix validator output format']\n  };\n}\n\n// Ensure all expected fields exist\nconst defaults = {\n  overall_score: 50,\n  completeness: 50,\n  correctness: 50,\n  code_quality: 50,\n  testing: 50,\n  documentation: 50,\n  security: 50,\n  decision: 'FIX',\n  reasoning: 'No reasoning provided',\n  critical_issues: [],\n  minor_issues: [],\n  next_steps: []\n};\n\nfor (const key of Object.keys(defaults)) {\n  if (qualityReport[key] === undefined) {\n    qualityReport[key] = defaults[key];\n  }\n}\n\n// Calculate iteration - get from original packet or default to 0\nconst currentIteration = originalPacket.iteration || flowData.iteration || 0;\n\nreturn {\n  json: {\n    // Preserve original packet fields\n    ...originalPacket,\n    // Add generated output\n    generatedOutput: flowData.generatedOutput,\n    // Add quality fields\n    qualityScore: qualityReport.overall_score,\n    decision: qualityReport.decision,\n    qualityReport: qualityReport,\n    qualityNextSteps: qualityReport.next_steps || [],\n    iteration: currentIteration + 1,\n    maxIterations: 5\n  }\n};"},"name":"Parse Quality Score","type":"n8n-nodes-base.code","typeVersion":2,"position":[1472,4720],"id":"0d1641bd-5014-4a9d-8440-ff346db0c170"},{"parameters":{"conditions":{"boolean":[{"value1":"={{ $json.validationPassed }}","operation":"true"}]},"options":{}},"name":"Decision Router","type":"n8n-nodes-base.if","typeVersion":2,"position":[3280,4720],"id":"c0cad35e-1022-4145-9c8e-e8e5ccf385e3"},{"parameters":{"jsCode":"const fs = require('fs');\nconst path = require('path');\nconst packet = $input.item.json;\n\nconst now = new Date();\nconst timestamp = now.toISOString().replace(/[:.]/g, '-');\n\n// Get issueId - it should now be properly preserved through the pipeline\nconst issueId = packet.issueId || packet.packetID || 'unknown';\nconst title = packet.title || 'Untitled';\nconst titleClean = title.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50);\n\n// Get generated code from multiple possible locations\nconst generatedCode = packet.improvedCode\n  || packet.generatedOutput\n  || packet.codeToTest\n  || packet.output\n  || '(no code generated)';\n\nconst filename = `${issueId}-${titleClean}-${timestamp}.md`;\nconst filePath = `/mnt/n8n-nas/packet_outputs/generated_code/${filename}`;\n\n// Build markdown\nconst parts = [];\nparts.push(`# ${issueId}: ${title}`);\nparts.push('');\nparts.push(`**Issue ID:** ${issueId}`);\nparts.push(`**Packet ID:** ${packet.packetID || 'N/A'}`);\nparts.push(`**Quality Score:** ${packet.qualityScore || 0}/100`);\nparts.push(`**Final Score:** ${packet.finalScore || packet.qualityScore || 0}/100`);\nparts.push(`**Iterations:** ${packet.iteration || 1}`);\nparts.push(`**Timestamp:** ${now.toISOString()}`);\nparts.push(`**Status:** Accepted`);\nparts.push('');\nparts.push('## Implementation');\nparts.push('');\nparts.push('```json');\nparts.push(generatedCode);\nparts.push('```');\nparts.push('');\nparts.push('## Quality Report');\nparts.push('');\ntry {\n  parts.push(JSON.stringify(packet.qualityReport || {}, null, 2));\n} catch (e) {\n  parts.push('{}');\n}\nparts.push('');\nparts.push('---');\nparts.push('*Generated by Packet Processor workflow*');\n\nconst markdown = parts.join('\\n');\n\n// Ensure directory exists\nconst dir = path.dirname(filePath);\nif (!fs.existsSync(dir)) {\n  fs.mkdirSync(dir, { recursive: true });\n}\n\n// Write file\nfs.writeFileSync(filePath, markdown, 'utf8');\n\nreturn {\n  json: {\n    success: true,\n    filePath: filePath,\n    filename: filename,\n    issueId: issueId,\n    packetID: packet.packetID,\n    finalScore: packet.finalScore || packet.qualityScore\n  }\n};"},"name":"Save Accepted Output","type":"n8n-nodes-base.code","typeVersion":2,"position":[3680,4624],"id":"9aa6e523-c746-41e1-a0ef-8683be163900"},{"parameters":{"conditions":{"number":[{"value1":"={{ $json.iteration }}","operation":"largerEqual","value2":"={{ $json.maxIterations }}"}]},"options":{}},"name":"Check Max Iterations","type":"n8n-nodes-base.if","typeVersion":2,"position":[3680,4832],"id":"e575ea55-6001-4cbb-999d-e84c70697c40"},{"parameters":{},"name":"Loop Back","type":"n8n-nodes-base.noOp","typeVersion":1,"position":[3888,4928],"id":"e35bbf95-f550-4a90-902e-3986f96a82af"},{"parameters":{"jsCode":"// Get original packet data\nconst originalPacket = $('Extract Packet Data').item.json;\n// Get flow data with quality results\nconst flowData = $input.item.json;\nconst generatedCode = flowData.generatedOutput || \"\";\n\n// Determine language\nlet language = 'python';\nif (generatedCode.includes('import ') || generatedCode.includes('def ')) {\n  language = 'python';\n} else if (generatedCode.includes('function ') || generatedCode.includes('const ') || generatedCode.includes('let ')) {\n  language = 'javascript';\n} else if (generatedCode.includes('package ') || generatedCode.includes('func ')) {\n  language = 'go';\n}\n\n// Check if it has test cases\nconst hasTests = generatedCode.includes('test_') ||\n                 generatedCode.includes('describe(') ||\n                 generatedCode.includes('it(') ||\n                 generatedCode.includes('assert');\n\nreturn {\n  json: {\n    // Preserve original packet and flow data\n    ...flowData,\n    // Ensure original packet fields are present\n    issueId: originalPacket.issueId,\n    title: originalPacket.title,\n    description: originalPacket.description,\n    packetID: originalPacket.packetID,\n    // Add test extraction results\n    language: language,\n    hasTests: hasTests,\n    codeToTest: generatedCode\n  }\n};"},"name":"Extract Test Requirements","type":"n8n-nodes-base.code","typeVersion":2,"position":[2064,4544],"id":"b7c5f6df-b7eb-4e8f-b127-b9ccc2420b48"},{"parameters":{"jsCode":"const { execSync } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\nconst packet = $input.item.json;\n\n// Create temporary directory\nconst tmpDir = `/tmp/code-test-${Date.now()}`;\nfs.mkdirSync(tmpDir, { recursive: true });\n\nlet testResults = {\n  passed: false,\n  output: '',\n  error: '',\n  exitCode: -1,\n  duration: 0\n};\n\nconst startTime = Date.now();\n\ntry {\n  const codeToTest = packet.codeToTest || '';\n  const language = packet.language || 'unknown';\n\n  if (!codeToTest) {\n    throw new Error('No code to test');\n  }\n\n  if (language === 'python') {\n    // Write code to file\n    const codeFile = path.join(tmpDir, 'test_code.py');\n    fs.writeFileSync(codeFile, codeToTest, 'utf8');\n\n    // Run with timeout\n    const output = execSync(`python3 ${codeFile}`, {\n      cwd: tmpDir,\n      timeout: 30000,\n      encoding: 'utf8',\n      env: { ...process.env, PYTHONDONTWRITEBYTECODE: '1' }\n    });\n\n    testResults.passed = true;\n    testResults.output = output;\n    testResults.exitCode = 0;\n\n  } else if (language === 'javascript') {\n    // Write code to file\n    const codeFile = path.join(tmpDir, 'test_code.js');\n    fs.writeFileSync(codeFile, codeToTest, 'utf8');\n\n    // Run with Node.js\n    const output = execSync(`node ${codeFile}`, {\n      cwd: tmpDir,\n      timeout: 30000,\n      encoding: 'utf8'\n    });\n\n    testResults.passed = true;\n    testResults.output = output;\n    testResults.exitCode = 0;\n\n  } else {\n    // Unknown language - mark as skipped\n    testResults.passed = false;\n    testResults.error = `Testing not supported for language: ${language}`;\n    testResults.exitCode = -2;\n  }\n\n} catch (error) {\n  testResults.passed = false;\n  testResults.error = error.message || String(error);\n  testResults.output = error.stdout || '';\n  testResults.exitCode = error.status || -1;\n} finally {\n  testResults.duration = Date.now() - startTime;\n\n  // Cleanup\n  try {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  } catch (cleanupError) {\n    // Ignore cleanup errors\n  }\n}\n\nreturn {\n  json: {\n    ...packet,\n    testResults: testResults,\n    testedAt: new Date().toISOString()\n  }\n};"},"name":"Run Code Tests","type":"n8n-nodes-base.code","typeVersion":2,"position":[2256,4544],"id":"7c009b2c-0c2c-4c98-bb15-3bcf653b7016"},{"parameters":{"jsCode":"// Get original packet data\nconst originalPacket = $('Extract Packet Data').item.json;\n// Get flow data with test results\nconst flowData = $input.item.json;\nconst testResults = flowData.testResults || { passed: false, output: '', error: 'No test results' };\nconst qualityIssues = flowData.qualityReport?.critical_issues || [];\nconst nextSteps = flowData.qualityReport?.next_steps || [];\n\n// Build critical issues list\nlet criticalIssuesList = 'None identified';\nif (qualityIssues.length > 0) {\n  criticalIssuesList = qualityIssues.map((issue, i) => `${i + 1}. ${issue}`).join('\\n');\n}\n\n// Build next steps list\nlet nextStepsList = 'None identified';\nif (nextSteps.length > 0) {\n  nextStepsList = nextSteps.map((step, i) => `${i + 1}. ${step}`).join('\\n');\n}\n\n// Build test status\nconst testStatus = testResults.passed ? 'âœ… PASSED' : 'âŒ FAILED';\nconst testOutput = testResults.output || '(none)';\nconst testError = testResults.error ? `Error: ${testResults.error}` : '';\n\n// Build the prompt parts\nconst promptParts = [];\npromptParts.push('You are a PROACTIVE Code Editor. Your job is to FIX issues, not just identify them.');\npromptParts.push('');\npromptParts.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\npromptParts.push('');\npromptParts.push(`ğŸ“‹ TASK: ${originalPacket.issueId} - ${originalPacket.title}`);\npromptParts.push('');\npromptParts.push('ğŸ“ CURRENT CODE:');\npromptParts.push('```');\npromptParts.push(flowData.codeToTest || '(no code)');\npromptParts.push('```');\npromptParts.push('');\npromptParts.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\npromptParts.push('');\npromptParts.push(`ğŸ§ª TEST RESULTS: ${testStatus}`);\npromptParts.push('');\npromptParts.push('Output:');\npromptParts.push(testOutput);\nif (testError) {\n  promptParts.push('');\n  promptParts.push(testError);\n}\npromptParts.push('');\npromptParts.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\npromptParts.push('');\npromptParts.push(`ğŸ“Š QUALITY SCORE: ${flowData.qualityScore || 0}/100`);\npromptParts.push('');\npromptParts.push('Critical Issues:');\npromptParts.push(criticalIssuesList);\npromptParts.push('');\npromptParts.push('Required Fixes:');\npromptParts.push(nextStepsList);\npromptParts.push('');\npromptParts.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\npromptParts.push('');\npromptParts.push('YOUR MISSION:');\npromptParts.push('1. FIX all test failures');\npromptParts.push('2. FIX all critical issues');\npromptParts.push('3. ADD missing error handling');\npromptParts.push('4. ADD missing tests');\npromptParts.push('5. IMPROVE code quality');\npromptParts.push('');\npromptParts.push('Return ONLY valid JSON:');\npromptParts.push('{');\npromptParts.push('  \"decision\": \"APPROVE\" | \"ITERATE\" | \"REJECT\",');\npromptParts.push('  \"editor_score\": <0-100>,');\npromptParts.push('  \"improved_code\": \"<complete improved code>\",');\npromptParts.push('  \"fixes_applied\": [\"<fix1>\", ...],');\npromptParts.push('  \"tests_added\": [\"<test1>\", ...],');\npromptParts.push('  \"error_handling_added\": [\"<handler1>\", ...],');\npromptParts.push('  \"docs_added\": [\"<doc1>\", ...],');\npromptParts.push('  \"remaining_issues\": [\"<issue1>\", ...]');\npromptParts.push('}');\n\nconst editorPrompt = promptParts.join('\\n');\n\nreturn {\n  json: {\n    // Preserve all flow data\n    ...flowData,\n    // Ensure original packet fields are present\n    issueId: originalPacket.issueId,\n    title: originalPacket.title,\n    description: originalPacket.description,\n    packetID: originalPacket.packetID,\n    // Add editor prompt\n    editorPrompt: editorPrompt\n  }\n};"},"name":"Build Editor Prompt","type":"n8n-nodes-base.code","typeVersion":2,"position":[2464,4544],"id":"6716acd8-623b-48c4-b5df-021763f1c27d"},{"parameters":{"promptType":"define","text":"={{ $json.editorPrompt }}","options":{"systemMessage":"You are a PROACTIVE Code Editor. You don't just review - you FIX and IMPROVE.\n\nYOUR JOB:\n1. Review test execution results\n2. FIX any errors you find (don't just identify them!)\n3. ADD missing error handling\n4. ADD missing tests\n5. ADD missing documentation\n6. IMPROVE code quality\n7. Only APPROVE after you've made it EXCELLENT\n\nYOU CAN AND SHOULD:\n- Fix bugs and errors\n- Add try/catch blocks\n- Add input validation\n- Add test assertions\n- Add docstrings and comments\n- Improve variable names\n- Remove code smells\n\nDO NOT just say \"needs error handling\" - ADD the error handling!\nDO NOT just say \"needs tests\" - ADD the tests!\nDO NOT just say \"needs docs\" - ADD the documentation!\n\nOnly return APPROVE after you've actually FIXED everything.\n\nReturn ONLY valid JSON with your improvements.","maxIterations":5}},"name":"Editor Validator","type":"@n8n/n8n-nodes-langchain.agent","typeVersion":1.7,"position":[2656,4544],"id":"ea0d12d5-6f70-49a7-afe1-52a4554b1a8d"},{"parameters":{"model":{"__rl":true,"mode":"list","value":"mistralai/ministral-3-3b"},"builtInTools":{},"options":{"timeout":60000}},"name":"Editor Model","type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","typeVersion":1.3,"position":[2656,4752],"id":"19100908-42fa-4589-b80a-1c5cda4d2c91","credentials":{"openAiApi":{"id":"FYFVsKzjVFK0h0V2","name":"Bedroom LMStudio"}}},{"parameters":{"jsCode":"// Get original packet data\nconst originalPacket = $('Extract Packet Data').item.json;\n// Get flow data\nconst flowData = $('Build Editor Prompt').item.json;\n// Get editor output\nconst editorOutput = $input.item.json.output || \"\";\n\nlet editorDecision;\ntry {\n  const jsonMatch = editorOutput.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    editorDecision = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('No JSON found in editor output');\n  }\n} catch (e) {\n  // Fallback based on test results\n  const testPassed = flowData.testResults?.passed || false;\n  editorDecision = {\n    decision: 'ITERATE',\n    editor_score: testPassed ? 60 : 30,\n    improved_code: flowData.codeToTest || '',\n    fixes_applied: [],\n    tests_added: [],\n    error_handling_added: [],\n    docs_added: [],\n    remaining_issues: ['Editor failed to parse JSON - needs retry: ' + e.message],\n    reasoning: 'Editor output parse error'\n  };\n}\n\n// Use improved code if provided\nconst finalCode = editorDecision.improved_code || flowData.codeToTest || '';\n\n// Quality (30%) + Editor (70%) - Editor is MORE important now\nconst qualityScore = flowData.qualityScore || 50;\nconst editorScore = editorDecision.editor_score || 0;\nconst finalScore = Math.floor((qualityScore * 0.3) + (editorScore * 0.7));\n\n// Higher bar: need 85+ to approve\nconst validationPassed = editorDecision.decision === 'APPROVE' && finalScore >= 85;\n\nreturn {\n  json: {\n    // Preserve original packet fields (CRITICAL for Save Accepted Output)\n    issueId: originalPacket.issueId,\n    title: originalPacket.title,\n    description: originalPacket.description,\n    packetID: originalPacket.packetID,\n    // Preserve flow data\n    generatedOutput: flowData.generatedOutput,\n    codeToTest: flowData.codeToTest,\n    qualityScore: qualityScore,\n    qualityReport: flowData.qualityReport,\n    testResults: flowData.testResults,\n    iteration: flowData.iteration,\n    maxIterations: flowData.maxIterations,\n    // Add editor results\n    improvedCode: finalCode,\n    editorDecision: editorDecision.decision,\n    editorScore: editorScore,\n    finalScore: finalScore,\n    fixesApplied: editorDecision.fixes_applied || [],\n    testsAdded: editorDecision.tests_added || [],\n    errorHandlingAdded: editorDecision.error_handling_added || [],\n    docsAdded: editorDecision.docs_added || [],\n    remainingIssues: editorDecision.remaining_issues || [],\n    // Decision for router\n    validationPassed: validationPassed\n  }\n};"},"name":"Parse Editor Decision","type":"n8n-nodes-base.code","typeVersion":2,"position":[3008,4544],"id":"a8cd17e2-11b5-44d4-995d-92360e060e8a"},{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[1904,5152],"id":"7f262816-8f96-41a5-8776-0cf38cb1ab0e","name":"When clicking â€˜Execute workflowâ€™"}],"connections":{"Process Each Packet":{"main":[[],[{"node":"Extract Packet Data","type":"main","index":0}]]},"Extract Packet Data":{"main":[[{"node":"Format Work Prompt","type":"main","index":0}]]},"Format Work Prompt":{"main":[[{"node":"Worker Agent","type":"main","index":0}]]},"Worker Agent":{"main":[[{"node":"Build Quality Check Prompt","type":"main","index":0}]]},"GPT-OSS-20b Model":{"ai_languageModel":[[{"node":"Worker Agent","type":"ai_languageModel","index":0}]]},"Get row(s)":{"main":[[{"node":"Process Each Packet","type":"main","index":0}]]},"Build Quality Check Prompt":{"main":[[{"node":"Quality Validator","type":"main","index":0}]]},"Validator Model":{"ai_languageModel":[[{"node":"Quality Validator","type":"ai_languageModel","index":0}]]},"Quality Validator":{"main":[[{"node":"Parse Quality Score","type":"main","index":0}]]},"Parse Quality Score":{"main":[[{"node":"Extract Test Requirements","type":"main","index":0}]]},"Decision Router":{"main":[[{"node":"Save Accepted Output","type":"main","index":0}],[{"node":"Check Max Iterations","type":"main","index":0}]]},"Save Accepted Output":{"main":[[{"node":"Process Each Packet","type":"main","index":0}]]},"Check Max Iterations":{"main":[[{"node":"Process Each Packet","type":"main","index":0}],[{"node":"Loop Back","type":"main","index":0}]]},"Loop Back":{"main":[[{"node":"Format Work Prompt","type":"main","index":0}]]},"When clicking â€˜Execute workflowâ€™":{"main":[[{"node":"Get row(s)","type":"main","index":0}]]},"Extract Test Requirements":{"main":[[{"node":"Run Code Tests","type":"main","index":0}]]},"Run Code Tests":{"main":[[{"node":"Build Editor Prompt","type":"main","index":0}]]},"Build Editor Prompt":{"main":[[{"node":"Editor Validator","type":"main","index":0}]]},"Editor Model":{"ai_languageModel":[[{"node":"Editor Validator","type":"ai_languageModel","index":0}]]},"Editor Validator":{"main":[[{"node":"Parse Editor Decision","type":"main","index":0}]]},"Parse Editor Decision":{"main":[[{"node":"Decision Router","type":"main","index":0}]]},"Webhook Trigger":{"main":[[{"node":"Get row(s)","type":"main","index":0}]]}},"authors":"Bill Griffith","name":null,"description":null,"workflowPublishHistory":[{"createdAt":"2026-01-02T07:12:30.460Z","id":254,"workflowId":"Eav7gyLzr7RuGaeT","versionId":"d212309a-2ff1-40ee-b24e-8b64888bc99e","event":"activated","userId":"82ee42c3-23a4-46d2-8969-bfa414e739d3"}]}}